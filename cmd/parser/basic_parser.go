// Code generated from ./cmd/parser/Basic.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // Basic

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type BasicParser struct {
	*antlr.BaseParser
}

var BasicParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func basicParserInit() {
	staticData := &BasicParserStaticData
	staticData.LiteralNames = []string{
		"", "'$'", "'%'", "'RETURN'", "'PRINT'", "'GOTO'", "'GOSUB'", "'IF'",
		"'NEXT'", "'THEN'", "'REM'", "'CHR$'", "'MID$'", "'LEFT$'", "'RIGHT$'",
		"'STR$'", "'('", "')'", "'+'", "'-'", "'*'", "'/'", "'CLEAR'", "'>: '",
		"'<: '", "'>'", "'<'", "','", "'LIST'", "'RUN'", "'END'", "'LET'", "'='",
		"'FOR'", "'TO'", "'STEP'", "'INPUT'", "';'", "'DIM'", "'SQR'", "':'",
		"'TEXT'", "'HGR'", "'HGR2'", "'LEN'", "'CALL'", "'ASC'", "'HPLOT'",
		"'VPLOT'", "'PR#'", "'IN#'", "'VTAB'", "'HTAB'", "'HOME'", "'ON'", "'PDL'",
		"'PLOT'", "'PEEK'", "'POKE'", "'INT'", "'STOP'", "'HIMEM'", "'LOMEM'",
		"'FLASH'", "'INVERSE'", "'NORMAL'", "'ONERR'", "'SPC'", "'FRE'", "'POS'",
		"'USR'", "'TRACE'", "'NOTRACE'", "'AND'", "'OR'", "'DATA'", "'WAIT'",
		"'READ'", "'XDRAW'", "'DRAW'", "'AT'", "'DEF'", "'FN'", "'VAL'", "'TAB'",
		"'SPEED'", "'ROT'", "'SCALE'", "'COLOR'", "'HCOLOR'", "'HLIN'", "'VLIN'",
		"'SCRN'", "'POP'", "'SHLOAD'", "'SIN'", "'COS'", "'TAN'", "'ATN'", "'RND'",
		"'SGN'", "'EXP'", "'LOG'", "'ABS'", "'STORE'", "'RECALL'", "'GET'",
		"'^'", "'&'", "'GR'", "'NOT'", "'RESTORE'", "'SAVE'", "'LOAD'", "'?'",
		"'INCLUDE'", "'CLS'",
	}
	staticData.SymbolicNames = []string{
		"", "DOLLAR", "PERCENT", "RETURN", "PRINT", "GOTO", "GOSUB", "IF", "NEXT",
		"THEN", "REM", "CHR", "MID", "LEFT", "RIGHT", "STR", "LPAREN", "RPAREN",
		"PLUS", "MINUS", "TIMES", "DIV", "CLEAR", "GTE", "LTE", "GT", "LT",
		"COMMA", "LIST", "RUN", "END", "LET", "EQ", "FOR", "TO", "STEP", "INPUT",
		"SEMICOLON", "DIM", "SQR", "COLON", "TEXT", "HGR", "HGR2", "LEN", "CALL",
		"ASC", "HPLOT", "VPLOT", "PRNUMBER", "INNUMBER", "VTAB", "HTAB", "HOME",
		"ON", "PDL", "PLOT", "PEEK", "POKE", "INTF", "STOP", "HIMEM", "LOMEM",
		"FLASH", "INVERSE", "NORMAL", "ONERR", "SPC", "FRE", "POS", "USR", "TRACE",
		"NOTRACE", "AND", "OR", "DATA", "WAIT", "READ", "XDRAW", "DRAW", "AT",
		"DEF", "FN", "VAL", "TAB", "SPEED", "ROT", "SCALE", "COLOR", "HCOLOR",
		"HLIN", "VLIN", "SCRN", "POP", "SHLOAD", "SIN", "COS", "TAN", "ATN",
		"RND", "SGN", "EXP", "LOG", "ABS", "STORE", "RECALL", "GET", "EXPONENT",
		"AMPERSAND", "GR", "NOT", "RESTORE", "SAVE", "LOAD", "QUESTION", "INCLUDE",
		"CLS", "COMMENT", "STRINGLITERAL", "LETTERS", "NUMBER", "FLOAT", "WS",
	}
	staticData.RuleNames = []string{
		"prog", "line", "amperoper", "linenumber", "amprstmt", "statement",
		"vardecl", "printstmt1", "printlist", "getstmt", "letstmt", "variableassignment",
		"relop", "neq", "ifstmt", "forstmt1", "forstmt2", "nextstmt", "inputstmt",
		"readstmt", "dimstmt", "gotostmt", "gosubstmt", "pokestmt", "callstmt",
		"hplotstmt", "vplotstmt", "plotstmt", "ongotostmt", "ongosubstmt", "vtabstmnt",
		"htabstmnt", "himemstmt", "lomemstmt", "datastmt", "datum", "waitstmt",
		"xdrawstmt", "drawstmt", "defstmt", "tabstmt", "speedstmt", "rotstmt",
		"scalestmt", "colorstmt", "hcolorstmt", "hlinstmt", "vlinstmt", "onerrstmt",
		"prstmt", "instmt", "storestmt", "recallstmt", "liststmt", "popstmt",
		"amptstmt", "includestmt", "endstmt", "returnstmt", "restorestmt", "number",
		"func_", "signExpression", "exponentExpression", "multiplyingExpression",
		"addingExpression", "relationalExpression", "expression", "var_", "varname",
		"varsuffix", "varlist", "exprlist", "sqrfunc", "chrfunc", "lenfunc",
		"ascfunc", "midfunc", "pdlfunc", "peekfunc", "intfunc", "spcfunc", "frefunc",
		"posfunc", "usrfunc", "leftfunc", "rightfunc", "strfunc", "fnfunc",
		"valfunc", "scrnfunc", "sinfunc", "cosfunc", "tanfunc", "atnfunc", "rndfunc",
		"sgnfunc", "expfunc", "logfunc", "absfunc", "tabfunc",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 122, 909, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7,
		73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78,
		2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2,
		84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89,
		7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7,
		94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 99,
		2, 100, 7, 100, 1, 0, 4, 0, 204, 8, 0, 11, 0, 12, 0, 205, 1, 0, 1, 0, 1,
		1, 1, 1, 1, 1, 1, 1, 3, 1, 214, 8, 1, 5, 1, 216, 8, 1, 10, 1, 12, 1, 219,
		9, 1, 1, 1, 1, 1, 3, 1, 223, 8, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 4, 3, 4,
		230, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 235, 8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 3, 5, 302, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 5, 6, 309, 8, 6, 10,
		6, 12, 6, 312, 9, 6, 1, 7, 1, 7, 3, 7, 316, 8, 7, 1, 8, 1, 8, 1, 8, 3,
		8, 321, 8, 8, 5, 8, 323, 8, 8, 10, 8, 12, 8, 326, 9, 8, 1, 9, 1, 9, 1,
		9, 1, 10, 3, 10, 332, 8, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 11,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 3, 12, 354, 8, 12, 1, 13, 1, 13, 1, 13, 1, 14,
		1, 14, 1, 14, 3, 14, 362, 8, 14, 1, 14, 1, 14, 3, 14, 366, 8, 14, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 376, 8, 15, 1,
		15, 1, 15, 1, 15, 3, 15, 381, 8, 15, 3, 15, 383, 8, 15, 1, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 393, 8, 16, 1, 17, 1, 17,
		1, 17, 1, 17, 5, 17, 399, 8, 17, 10, 17, 12, 17, 402, 9, 17, 3, 17, 404,
		8, 17, 1, 18, 1, 18, 1, 18, 3, 18, 409, 8, 18, 1, 18, 1, 18, 1, 19, 1,
		19, 1, 19, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22,
		1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1,
		25, 1, 25, 1, 25, 3, 25, 438, 8, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25,
		5, 25, 445, 8, 25, 10, 25, 12, 25, 448, 9, 25, 1, 26, 1, 26, 1, 26, 1,
		26, 1, 26, 3, 26, 455, 8, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 5, 26,
		462, 8, 26, 10, 26, 12, 26, 465, 9, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1,
		27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 5, 28, 478, 8, 28, 10, 28,
		12, 28, 481, 9, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 5, 29, 489,
		8, 29, 10, 29, 12, 29, 492, 9, 29, 1, 30, 1, 30, 1, 30, 1, 31, 1, 31, 1,
		31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34,
		1, 34, 1, 34, 3, 34, 512, 8, 34, 5, 34, 514, 8, 34, 10, 34, 12, 34, 517,
		9, 34, 1, 35, 1, 35, 3, 35, 521, 8, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1,
		36, 1, 36, 3, 36, 529, 8, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37,
		1, 37, 3, 37, 538, 8, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1,
		38, 3, 38, 547, 8, 38, 1, 39, 1, 39, 3, 39, 551, 8, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 46, 1, 46,
		1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1,
		47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 1, 50, 1, 50,
		1, 50, 1, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 3, 53, 617,
		8, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 624, 8, 54, 1, 55, 1,
		55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 57, 1, 57, 1, 58, 1, 58, 1, 59, 1, 59,
		1, 60, 3, 60, 639, 8, 60, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1,
		61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61,
		1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1,
		61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61,
		678, 8, 61, 1, 62, 3, 62, 681, 8, 62, 1, 62, 3, 62, 684, 8, 62, 1, 62,
		1, 62, 1, 63, 1, 63, 1, 63, 5, 63, 691, 8, 63, 10, 63, 12, 63, 694, 9,
		63, 1, 64, 1, 64, 1, 64, 5, 64, 699, 8, 64, 10, 64, 12, 64, 702, 9, 64,
		1, 65, 1, 65, 1, 65, 5, 65, 707, 8, 65, 10, 65, 12, 65, 710, 9, 65, 1,
		66, 1, 66, 1, 66, 1, 66, 3, 66, 716, 8, 66, 1, 67, 1, 67, 1, 67, 1, 67,
		5, 67, 722, 8, 67, 10, 67, 12, 67, 725, 9, 67, 3, 67, 727, 8, 67, 1, 68,
		1, 68, 3, 68, 731, 8, 68, 1, 69, 1, 69, 5, 69, 735, 8, 69, 10, 69, 12,
		69, 738, 9, 69, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 5, 71, 745, 8, 71, 10,
		71, 12, 71, 748, 9, 71, 1, 72, 1, 72, 1, 72, 5, 72, 753, 8, 72, 10, 72,
		12, 72, 756, 9, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 74, 1, 74, 1,
		74, 1, 74, 1, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76,
		1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1,
		77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79,
		1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1,
		82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 84,
		1, 84, 1, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1,
		85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 87, 1, 87, 1, 87,
		1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1,
		89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 91,
		1, 91, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 93, 1,
		93, 1, 93, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 95, 1, 95,
		1, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 97, 1, 97, 1,
		97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99,
		1, 99, 1, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 0, 0, 101,
		0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36,
		38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72,
		74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106,
		108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136,
		138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166,
		168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196,
		198, 200, 0, 8, 2, 0, 4, 4, 114, 114, 2, 0, 27, 27, 37, 37, 1, 0, 18, 19,
		1, 0, 120, 121, 1, 0, 20, 21, 1, 0, 73, 74, 1, 0, 119, 120, 1, 0, 1, 2,
		961, 0, 203, 1, 0, 0, 0, 2, 209, 1, 0, 0, 0, 4, 224, 1, 0, 0, 0, 6, 226,
		1, 0, 0, 0, 8, 234, 1, 0, 0, 0, 10, 301, 1, 0, 0, 0, 12, 303, 1, 0, 0,
		0, 14, 313, 1, 0, 0, 0, 16, 317, 1, 0, 0, 0, 18, 327, 1, 0, 0, 0, 20, 331,
		1, 0, 0, 0, 22, 335, 1, 0, 0, 0, 24, 353, 1, 0, 0, 0, 26, 355, 1, 0, 0,
		0, 28, 358, 1, 0, 0, 0, 30, 367, 1, 0, 0, 0, 32, 384, 1, 0, 0, 0, 34, 394,
		1, 0, 0, 0, 36, 405, 1, 0, 0, 0, 38, 412, 1, 0, 0, 0, 40, 415, 1, 0, 0,
		0, 42, 418, 1, 0, 0, 0, 44, 421, 1, 0, 0, 0, 46, 424, 1, 0, 0, 0, 48, 429,
		1, 0, 0, 0, 50, 432, 1, 0, 0, 0, 52, 449, 1, 0, 0, 0, 54, 466, 1, 0, 0,
		0, 56, 471, 1, 0, 0, 0, 58, 482, 1, 0, 0, 0, 60, 493, 1, 0, 0, 0, 62, 496,
		1, 0, 0, 0, 64, 499, 1, 0, 0, 0, 66, 503, 1, 0, 0, 0, 68, 507, 1, 0, 0,
		0, 70, 520, 1, 0, 0, 0, 72, 522, 1, 0, 0, 0, 74, 530, 1, 0, 0, 0, 76, 539,
		1, 0, 0, 0, 78, 548, 1, 0, 0, 0, 80, 559, 1, 0, 0, 0, 82, 564, 1, 0, 0,
		0, 84, 568, 1, 0, 0, 0, 86, 572, 1, 0, 0, 0, 88, 576, 1, 0, 0, 0, 90, 580,
		1, 0, 0, 0, 92, 584, 1, 0, 0, 0, 94, 591, 1, 0, 0, 0, 96, 598, 1, 0, 0,
		0, 98, 602, 1, 0, 0, 0, 100, 605, 1, 0, 0, 0, 102, 608, 1, 0, 0, 0, 104,
		611, 1, 0, 0, 0, 106, 614, 1, 0, 0, 0, 108, 618, 1, 0, 0, 0, 110, 625,
		1, 0, 0, 0, 112, 628, 1, 0, 0, 0, 114, 631, 1, 0, 0, 0, 116, 633, 1, 0,
		0, 0, 118, 635, 1, 0, 0, 0, 120, 638, 1, 0, 0, 0, 122, 677, 1, 0, 0, 0,
		124, 680, 1, 0, 0, 0, 126, 687, 1, 0, 0, 0, 128, 695, 1, 0, 0, 0, 130,
		703, 1, 0, 0, 0, 132, 711, 1, 0, 0, 0, 134, 726, 1, 0, 0, 0, 136, 728,
		1, 0, 0, 0, 138, 732, 1, 0, 0, 0, 140, 739, 1, 0, 0, 0, 142, 741, 1, 0,
		0, 0, 144, 749, 1, 0, 0, 0, 146, 757, 1, 0, 0, 0, 148, 762, 1, 0, 0, 0,
		150, 767, 1, 0, 0, 0, 152, 772, 1, 0, 0, 0, 154, 777, 1, 0, 0, 0, 156,
		786, 1, 0, 0, 0, 158, 791, 1, 0, 0, 0, 160, 796, 1, 0, 0, 0, 162, 801,
		1, 0, 0, 0, 164, 806, 1, 0, 0, 0, 166, 811, 1, 0, 0, 0, 168, 816, 1, 0,
		0, 0, 170, 821, 1, 0, 0, 0, 172, 828, 1, 0, 0, 0, 174, 835, 1, 0, 0, 0,
		176, 840, 1, 0, 0, 0, 178, 846, 1, 0, 0, 0, 180, 851, 1, 0, 0, 0, 182,
		858, 1, 0, 0, 0, 184, 863, 1, 0, 0, 0, 186, 868, 1, 0, 0, 0, 188, 873,
		1, 0, 0, 0, 190, 878, 1, 0, 0, 0, 192, 883, 1, 0, 0, 0, 194, 888, 1, 0,
		0, 0, 196, 893, 1, 0, 0, 0, 198, 898, 1, 0, 0, 0, 200, 903, 1, 0, 0, 0,
		202, 204, 3, 2, 1, 0, 203, 202, 1, 0, 0, 0, 204, 205, 1, 0, 0, 0, 205,
		203, 1, 0, 0, 0, 205, 206, 1, 0, 0, 0, 206, 207, 1, 0, 0, 0, 207, 208,
		5, 0, 0, 1, 208, 1, 1, 0, 0, 0, 209, 222, 3, 6, 3, 0, 210, 217, 3, 8, 4,
		0, 211, 213, 5, 40, 0, 0, 212, 214, 3, 8, 4, 0, 213, 212, 1, 0, 0, 0, 213,
		214, 1, 0, 0, 0, 214, 216, 1, 0, 0, 0, 215, 211, 1, 0, 0, 0, 216, 219,
		1, 0, 0, 0, 217, 215, 1, 0, 0, 0, 217, 218, 1, 0, 0, 0, 218, 223, 1, 0,
		0, 0, 219, 217, 1, 0, 0, 0, 220, 223, 5, 117, 0, 0, 221, 223, 5, 10, 0,
		0, 222, 210, 1, 0, 0, 0, 222, 220, 1, 0, 0, 0, 222, 221, 1, 0, 0, 0, 223,
		3, 1, 0, 0, 0, 224, 225, 5, 108, 0, 0, 225, 5, 1, 0, 0, 0, 226, 227, 5,
		120, 0, 0, 227, 7, 1, 0, 0, 0, 228, 230, 3, 4, 2, 0, 229, 228, 1, 0, 0,
		0, 229, 230, 1, 0, 0, 0, 230, 231, 1, 0, 0, 0, 231, 235, 3, 10, 5, 0, 232,
		235, 5, 117, 0, 0, 233, 235, 5, 10, 0, 0, 234, 229, 1, 0, 0, 0, 234, 232,
		1, 0, 0, 0, 234, 233, 1, 0, 0, 0, 235, 9, 1, 0, 0, 0, 236, 302, 5, 116,
		0, 0, 237, 302, 5, 113, 0, 0, 238, 302, 5, 112, 0, 0, 239, 302, 5, 71,
		0, 0, 240, 302, 5, 72, 0, 0, 241, 302, 5, 63, 0, 0, 242, 302, 5, 64, 0,
		0, 243, 302, 5, 109, 0, 0, 244, 302, 5, 65, 0, 0, 245, 302, 5, 94, 0, 0,
		246, 302, 5, 22, 0, 0, 247, 302, 5, 29, 0, 0, 248, 302, 5, 60, 0, 0, 249,
		302, 5, 41, 0, 0, 250, 302, 5, 53, 0, 0, 251, 302, 5, 42, 0, 0, 252, 302,
		5, 43, 0, 0, 253, 302, 3, 114, 57, 0, 254, 302, 3, 116, 58, 0, 255, 302,
		3, 118, 59, 0, 256, 302, 3, 110, 55, 0, 257, 302, 3, 108, 54, 0, 258, 302,
		3, 106, 53, 0, 259, 302, 3, 102, 51, 0, 260, 302, 3, 18, 9, 0, 261, 302,
		3, 104, 52, 0, 262, 302, 3, 34, 17, 0, 263, 302, 3, 100, 50, 0, 264, 302,
		3, 98, 49, 0, 265, 302, 3, 96, 48, 0, 266, 302, 3, 92, 46, 0, 267, 302,
		3, 94, 47, 0, 268, 302, 3, 88, 44, 0, 269, 302, 3, 82, 41, 0, 270, 302,
		3, 86, 43, 0, 271, 302, 3, 84, 42, 0, 272, 302, 3, 90, 45, 0, 273, 302,
		3, 64, 32, 0, 274, 302, 3, 66, 33, 0, 275, 302, 3, 14, 7, 0, 276, 302,
		3, 46, 23, 0, 277, 302, 3, 54, 27, 0, 278, 302, 3, 56, 28, 0, 279, 302,
		3, 58, 29, 0, 280, 302, 3, 28, 14, 0, 281, 302, 3, 30, 15, 0, 282, 302,
		3, 32, 16, 0, 283, 302, 3, 36, 18, 0, 284, 302, 3, 80, 40, 0, 285, 302,
		3, 40, 20, 0, 286, 302, 3, 42, 21, 0, 287, 302, 3, 44, 22, 0, 288, 302,
		3, 48, 24, 0, 289, 302, 3, 38, 19, 0, 290, 302, 3, 50, 25, 0, 291, 302,
		3, 52, 26, 0, 292, 302, 3, 60, 30, 0, 293, 302, 3, 62, 31, 0, 294, 302,
		3, 72, 36, 0, 295, 302, 3, 68, 34, 0, 296, 302, 3, 74, 37, 0, 297, 302,
		3, 76, 38, 0, 298, 302, 3, 78, 39, 0, 299, 302, 3, 20, 10, 0, 300, 302,
		3, 112, 56, 0, 301, 236, 1, 0, 0, 0, 301, 237, 1, 0, 0, 0, 301, 238, 1,
		0, 0, 0, 301, 239, 1, 0, 0, 0, 301, 240, 1, 0, 0, 0, 301, 241, 1, 0, 0,
		0, 301, 242, 1, 0, 0, 0, 301, 243, 1, 0, 0, 0, 301, 244, 1, 0, 0, 0, 301,
		245, 1, 0, 0, 0, 301, 246, 1, 0, 0, 0, 301, 247, 1, 0, 0, 0, 301, 248,
		1, 0, 0, 0, 301, 249, 1, 0, 0, 0, 301, 250, 1, 0, 0, 0, 301, 251, 1, 0,
		0, 0, 301, 252, 1, 0, 0, 0, 301, 253, 1, 0, 0, 0, 301, 254, 1, 0, 0, 0,
		301, 255, 1, 0, 0, 0, 301, 256, 1, 0, 0, 0, 301, 257, 1, 0, 0, 0, 301,
		258, 1, 0, 0, 0, 301, 259, 1, 0, 0, 0, 301, 260, 1, 0, 0, 0, 301, 261,
		1, 0, 0, 0, 301, 262, 1, 0, 0, 0, 301, 263, 1, 0, 0, 0, 301, 264, 1, 0,
		0, 0, 301, 265, 1, 0, 0, 0, 301, 266, 1, 0, 0, 0, 301, 267, 1, 0, 0, 0,
		301, 268, 1, 0, 0, 0, 301, 269, 1, 0, 0, 0, 301, 270, 1, 0, 0, 0, 301,
		271, 1, 0, 0, 0, 301, 272, 1, 0, 0, 0, 301, 273, 1, 0, 0, 0, 301, 274,
		1, 0, 0, 0, 301, 275, 1, 0, 0, 0, 301, 276, 1, 0, 0, 0, 301, 277, 1, 0,
		0, 0, 301, 278, 1, 0, 0, 0, 301, 279, 1, 0, 0, 0, 301, 280, 1, 0, 0, 0,
		301, 281, 1, 0, 0, 0, 301, 282, 1, 0, 0, 0, 301, 283, 1, 0, 0, 0, 301,
		284, 1, 0, 0, 0, 301, 285, 1, 0, 0, 0, 301, 286, 1, 0, 0, 0, 301, 287,
		1, 0, 0, 0, 301, 288, 1, 0, 0, 0, 301, 289, 1, 0, 0, 0, 301, 290, 1, 0,
		0, 0, 301, 291, 1, 0, 0, 0, 301, 292, 1, 0, 0, 0, 301, 293, 1, 0, 0, 0,
		301, 294, 1, 0, 0, 0, 301, 295, 1, 0, 0, 0, 301, 296, 1, 0, 0, 0, 301,
		297, 1, 0, 0, 0, 301, 298, 1, 0, 0, 0, 301, 299, 1, 0, 0, 0, 301, 300,
		1, 0, 0, 0, 302, 11, 1, 0, 0, 0, 303, 310, 3, 136, 68, 0, 304, 305, 5,
		16, 0, 0, 305, 306, 3, 144, 72, 0, 306, 307, 5, 17, 0, 0, 307, 309, 1,
		0, 0, 0, 308, 304, 1, 0, 0, 0, 309, 312, 1, 0, 0, 0, 310, 308, 1, 0, 0,
		0, 310, 311, 1, 0, 0, 0, 311, 13, 1, 0, 0, 0, 312, 310, 1, 0, 0, 0, 313,
		315, 7, 0, 0, 0, 314, 316, 3, 16, 8, 0, 315, 314, 1, 0, 0, 0, 315, 316,
		1, 0, 0, 0, 316, 15, 1, 0, 0, 0, 317, 324, 3, 134, 67, 0, 318, 320, 7,
		1, 0, 0, 319, 321, 3, 134, 67, 0, 320, 319, 1, 0, 0, 0, 320, 321, 1, 0,
		0, 0, 321, 323, 1, 0, 0, 0, 322, 318, 1, 0, 0, 0, 323, 326, 1, 0, 0, 0,
		324, 322, 1, 0, 0, 0, 324, 325, 1, 0, 0, 0, 325, 17, 1, 0, 0, 0, 326, 324,
		1, 0, 0, 0, 327, 328, 5, 106, 0, 0, 328, 329, 3, 144, 72, 0, 329, 19, 1,
		0, 0, 0, 330, 332, 5, 31, 0, 0, 331, 330, 1, 0, 0, 0, 331, 332, 1, 0, 0,
		0, 332, 333, 1, 0, 0, 0, 333, 334, 3, 22, 11, 0, 334, 21, 1, 0, 0, 0, 335,
		336, 3, 12, 6, 0, 336, 337, 5, 32, 0, 0, 337, 338, 3, 144, 72, 0, 338,
		23, 1, 0, 0, 0, 339, 354, 5, 23, 0, 0, 340, 341, 5, 25, 0, 0, 341, 354,
		5, 32, 0, 0, 342, 343, 5, 32, 0, 0, 343, 354, 5, 25, 0, 0, 344, 354, 5,
		24, 0, 0, 345, 346, 5, 26, 0, 0, 346, 354, 5, 32, 0, 0, 347, 348, 5, 32,
		0, 0, 348, 354, 5, 26, 0, 0, 349, 354, 3, 26, 13, 0, 350, 354, 5, 32, 0,
		0, 351, 354, 5, 25, 0, 0, 352, 354, 5, 26, 0, 0, 353, 339, 1, 0, 0, 0,
		353, 340, 1, 0, 0, 0, 353, 342, 1, 0, 0, 0, 353, 344, 1, 0, 0, 0, 353,
		345, 1, 0, 0, 0, 353, 347, 1, 0, 0, 0, 353, 349, 1, 0, 0, 0, 353, 350,
		1, 0, 0, 0, 353, 351, 1, 0, 0, 0, 353, 352, 1, 0, 0, 0, 354, 25, 1, 0,
		0, 0, 355, 356, 5, 26, 0, 0, 356, 357, 5, 25, 0, 0, 357, 27, 1, 0, 0, 0,
		358, 359, 5, 7, 0, 0, 359, 361, 3, 134, 67, 0, 360, 362, 5, 9, 0, 0, 361,
		360, 1, 0, 0, 0, 361, 362, 1, 0, 0, 0, 362, 365, 1, 0, 0, 0, 363, 366,
		3, 10, 5, 0, 364, 366, 3, 6, 3, 0, 365, 363, 1, 0, 0, 0, 365, 364, 1, 0,
		0, 0, 366, 29, 1, 0, 0, 0, 367, 368, 5, 33, 0, 0, 368, 369, 3, 12, 6, 0,
		369, 370, 5, 32, 0, 0, 370, 371, 3, 134, 67, 0, 371, 372, 5, 34, 0, 0,
		372, 375, 3, 134, 67, 0, 373, 374, 5, 35, 0, 0, 374, 376, 3, 134, 67, 0,
		375, 373, 1, 0, 0, 0, 375, 376, 1, 0, 0, 0, 376, 382, 1, 0, 0, 0, 377,
		378, 3, 10, 5, 0, 378, 380, 5, 8, 0, 0, 379, 381, 3, 12, 6, 0, 380, 379,
		1, 0, 0, 0, 380, 381, 1, 0, 0, 0, 381, 383, 1, 0, 0, 0, 382, 377, 1, 0,
		0, 0, 382, 383, 1, 0, 0, 0, 383, 31, 1, 0, 0, 0, 384, 385, 5, 33, 0, 0,
		385, 386, 3, 12, 6, 0, 386, 387, 5, 32, 0, 0, 387, 388, 3, 134, 67, 0,
		388, 389, 5, 34, 0, 0, 389, 392, 3, 134, 67, 0, 390, 391, 5, 35, 0, 0,
		391, 393, 3, 134, 67, 0, 392, 390, 1, 0, 0, 0, 392, 393, 1, 0, 0, 0, 393,
		33, 1, 0, 0, 0, 394, 403, 5, 8, 0, 0, 395, 400, 3, 12, 6, 0, 396, 397,
		5, 27, 0, 0, 397, 399, 3, 12, 6, 0, 398, 396, 1, 0, 0, 0, 399, 402, 1,
		0, 0, 0, 400, 398, 1, 0, 0, 0, 400, 401, 1, 0, 0, 0, 401, 404, 1, 0, 0,
		0, 402, 400, 1, 0, 0, 0, 403, 395, 1, 0, 0, 0, 403, 404, 1, 0, 0, 0, 404,
		35, 1, 0, 0, 0, 405, 408, 5, 36, 0, 0, 406, 407, 5, 118, 0, 0, 407, 409,
		7, 1, 0, 0, 408, 406, 1, 0, 0, 0, 408, 409, 1, 0, 0, 0, 409, 410, 1, 0,
		0, 0, 410, 411, 3, 142, 71, 0, 411, 37, 1, 0, 0, 0, 412, 413, 5, 77, 0,
		0, 413, 414, 3, 142, 71, 0, 414, 39, 1, 0, 0, 0, 415, 416, 5, 38, 0, 0,
		416, 417, 3, 142, 71, 0, 417, 41, 1, 0, 0, 0, 418, 419, 5, 5, 0, 0, 419,
		420, 3, 6, 3, 0, 420, 43, 1, 0, 0, 0, 421, 422, 5, 6, 0, 0, 422, 423, 3,
		134, 67, 0, 423, 45, 1, 0, 0, 0, 424, 425, 5, 58, 0, 0, 425, 426, 3, 134,
		67, 0, 426, 427, 5, 27, 0, 0, 427, 428, 3, 134, 67, 0, 428, 47, 1, 0, 0,
		0, 429, 430, 5, 45, 0, 0, 430, 431, 3, 144, 72, 0, 431, 49, 1, 0, 0, 0,
		432, 437, 5, 47, 0, 0, 433, 434, 3, 134, 67, 0, 434, 435, 5, 27, 0, 0,
		435, 436, 3, 134, 67, 0, 436, 438, 1, 0, 0, 0, 437, 433, 1, 0, 0, 0, 437,
		438, 1, 0, 0, 0, 438, 446, 1, 0, 0, 0, 439, 440, 5, 34, 0, 0, 440, 441,
		3, 134, 67, 0, 441, 442, 5, 27, 0, 0, 442, 443, 3, 134, 67, 0, 443, 445,
		1, 0, 0, 0, 444, 439, 1, 0, 0, 0, 445, 448, 1, 0, 0, 0, 446, 444, 1, 0,
		0, 0, 446, 447, 1, 0, 0, 0, 447, 51, 1, 0, 0, 0, 448, 446, 1, 0, 0, 0,
		449, 454, 5, 48, 0, 0, 450, 451, 3, 134, 67, 0, 451, 452, 5, 27, 0, 0,
		452, 453, 3, 134, 67, 0, 453, 455, 1, 0, 0, 0, 454, 450, 1, 0, 0, 0, 454,
		455, 1, 0, 0, 0, 455, 463, 1, 0, 0, 0, 456, 457, 5, 34, 0, 0, 457, 458,
		3, 134, 67, 0, 458, 459, 5, 27, 0, 0, 459, 460, 3, 134, 67, 0, 460, 462,
		1, 0, 0, 0, 461, 456, 1, 0, 0, 0, 462, 465, 1, 0, 0, 0, 463, 461, 1, 0,
		0, 0, 463, 464, 1, 0, 0, 0, 464, 53, 1, 0, 0, 0, 465, 463, 1, 0, 0, 0,
		466, 467, 5, 56, 0, 0, 467, 468, 3, 134, 67, 0, 468, 469, 5, 27, 0, 0,
		469, 470, 3, 134, 67, 0, 470, 55, 1, 0, 0, 0, 471, 472, 5, 54, 0, 0, 472,
		473, 3, 134, 67, 0, 473, 474, 5, 5, 0, 0, 474, 479, 3, 6, 3, 0, 475, 476,
		5, 27, 0, 0, 476, 478, 3, 6, 3, 0, 477, 475, 1, 0, 0, 0, 478, 481, 1, 0,
		0, 0, 479, 477, 1, 0, 0, 0, 479, 480, 1, 0, 0, 0, 480, 57, 1, 0, 0, 0,
		481, 479, 1, 0, 0, 0, 482, 483, 5, 54, 0, 0, 483, 484, 3, 134, 67, 0, 484,
		485, 5, 6, 0, 0, 485, 490, 3, 6, 3, 0, 486, 487, 5, 27, 0, 0, 487, 489,
		3, 6, 3, 0, 488, 486, 1, 0, 0, 0, 489, 492, 1, 0, 0, 0, 490, 488, 1, 0,
		0, 0, 490, 491, 1, 0, 0, 0, 491, 59, 1, 0, 0, 0, 492, 490, 1, 0, 0, 0,
		493, 494, 5, 51, 0, 0, 494, 495, 3, 134, 67, 0, 495, 61, 1, 0, 0, 0, 496,
		497, 5, 52, 0, 0, 497, 498, 3, 134, 67, 0, 498, 63, 1, 0, 0, 0, 499, 500,
		5, 61, 0, 0, 500, 501, 5, 40, 0, 0, 501, 502, 3, 134, 67, 0, 502, 65, 1,
		0, 0, 0, 503, 504, 5, 62, 0, 0, 504, 505, 5, 40, 0, 0, 505, 506, 3, 134,
		67, 0, 506, 67, 1, 0, 0, 0, 507, 508, 5, 75, 0, 0, 508, 515, 3, 70, 35,
		0, 509, 511, 5, 27, 0, 0, 510, 512, 3, 70, 35, 0, 511, 510, 1, 0, 0, 0,
		511, 512, 1, 0, 0, 0, 512, 514, 1, 0, 0, 0, 513, 509, 1, 0, 0, 0, 514,
		517, 1, 0, 0, 0, 515, 513, 1, 0, 0, 0, 515, 516, 1, 0, 0, 0, 516, 69, 1,
		0, 0, 0, 517, 515, 1, 0, 0, 0, 518, 521, 3, 120, 60, 0, 519, 521, 5, 118,
		0, 0, 520, 518, 1, 0, 0, 0, 520, 519, 1, 0, 0, 0, 521, 71, 1, 0, 0, 0,
		522, 523, 5, 76, 0, 0, 523, 524, 3, 134, 67, 0, 524, 525, 5, 27, 0, 0,
		525, 528, 3, 134, 67, 0, 526, 527, 5, 27, 0, 0, 527, 529, 3, 134, 67, 0,
		528, 526, 1, 0, 0, 0, 528, 529, 1, 0, 0, 0, 529, 73, 1, 0, 0, 0, 530, 531,
		5, 78, 0, 0, 531, 537, 3, 134, 67, 0, 532, 533, 5, 80, 0, 0, 533, 534,
		3, 134, 67, 0, 534, 535, 5, 27, 0, 0, 535, 536, 3, 134, 67, 0, 536, 538,
		1, 0, 0, 0, 537, 532, 1, 0, 0, 0, 537, 538, 1, 0, 0, 0, 538, 75, 1, 0,
		0, 0, 539, 540, 5, 79, 0, 0, 540, 546, 3, 134, 67, 0, 541, 542, 5, 80,
		0, 0, 542, 543, 3, 134, 67, 0, 543, 544, 5, 27, 0, 0, 544, 545, 3, 134,
		67, 0, 545, 547, 1, 0, 0, 0, 546, 541, 1, 0, 0, 0, 546, 547, 1, 0, 0, 0,
		547, 77, 1, 0, 0, 0, 548, 550, 5, 81, 0, 0, 549, 551, 5, 82, 0, 0, 550,
		549, 1, 0, 0, 0, 550, 551, 1, 0, 0, 0, 551, 552, 1, 0, 0, 0, 552, 553,
		3, 136, 68, 0, 553, 554, 5, 16, 0, 0, 554, 555, 3, 136, 68, 0, 555, 556,
		5, 17, 0, 0, 556, 557, 5, 32, 0, 0, 557, 558, 3, 134, 67, 0, 558, 79, 1,
		0, 0, 0, 559, 560, 5, 84, 0, 0, 560, 561, 5, 16, 0, 0, 561, 562, 3, 134,
		67, 0, 562, 563, 5, 17, 0, 0, 563, 81, 1, 0, 0, 0, 564, 565, 5, 85, 0,
		0, 565, 566, 5, 32, 0, 0, 566, 567, 3, 134, 67, 0, 567, 83, 1, 0, 0, 0,
		568, 569, 5, 86, 0, 0, 569, 570, 5, 32, 0, 0, 570, 571, 3, 134, 67, 0,
		571, 85, 1, 0, 0, 0, 572, 573, 5, 87, 0, 0, 573, 574, 5, 32, 0, 0, 574,
		575, 3, 134, 67, 0, 575, 87, 1, 0, 0, 0, 576, 577, 5, 88, 0, 0, 577, 578,
		5, 32, 0, 0, 578, 579, 3, 134, 67, 0, 579, 89, 1, 0, 0, 0, 580, 581, 5,
		89, 0, 0, 581, 582, 5, 32, 0, 0, 582, 583, 3, 134, 67, 0, 583, 91, 1, 0,
		0, 0, 584, 585, 5, 90, 0, 0, 585, 586, 3, 134, 67, 0, 586, 587, 5, 27,
		0, 0, 587, 588, 3, 134, 67, 0, 588, 589, 5, 80, 0, 0, 589, 590, 3, 134,
		67, 0, 590, 93, 1, 0, 0, 0, 591, 592, 5, 91, 0, 0, 592, 593, 3, 134, 67,
		0, 593, 594, 5, 27, 0, 0, 594, 595, 3, 134, 67, 0, 595, 596, 5, 80, 0,
		0, 596, 597, 3, 134, 67, 0, 597, 95, 1, 0, 0, 0, 598, 599, 5, 66, 0, 0,
		599, 600, 5, 5, 0, 0, 600, 601, 3, 6, 3, 0, 601, 97, 1, 0, 0, 0, 602, 603,
		5, 49, 0, 0, 603, 604, 5, 120, 0, 0, 604, 99, 1, 0, 0, 0, 605, 606, 5,
		50, 0, 0, 606, 607, 5, 120, 0, 0, 607, 101, 1, 0, 0, 0, 608, 609, 5, 104,
		0, 0, 609, 610, 3, 12, 6, 0, 610, 103, 1, 0, 0, 0, 611, 612, 5, 105, 0,
		0, 612, 613, 3, 12, 6, 0, 613, 105, 1, 0, 0, 0, 614, 616, 5, 28, 0, 0,
		615, 617, 3, 134, 67, 0, 616, 615, 1, 0, 0, 0, 616, 617, 1, 0, 0, 0, 617,
		107, 1, 0, 0, 0, 618, 623, 5, 93, 0, 0, 619, 620, 3, 134, 67, 0, 620, 621,
		5, 27, 0, 0, 621, 622, 3, 134, 67, 0, 622, 624, 1, 0, 0, 0, 623, 619, 1,
		0, 0, 0, 623, 624, 1, 0, 0, 0, 624, 109, 1, 0, 0, 0, 625, 626, 5, 108,
		0, 0, 626, 627, 3, 134, 67, 0, 627, 111, 1, 0, 0, 0, 628, 629, 5, 115,
		0, 0, 629, 630, 3, 134, 67, 0, 630, 113, 1, 0, 0, 0, 631, 632, 5, 30, 0,
		0, 632, 115, 1, 0, 0, 0, 633, 634, 5, 3, 0, 0, 634, 117, 1, 0, 0, 0, 635,
		636, 5, 111, 0, 0, 636, 119, 1, 0, 0, 0, 637, 639, 7, 2, 0, 0, 638, 637,
		1, 0, 0, 0, 638, 639, 1, 0, 0, 0, 639, 640, 1, 0, 0, 0, 640, 641, 7, 3,
		0, 0, 641, 121, 1, 0, 0, 0, 642, 678, 5, 118, 0, 0, 643, 678, 3, 120, 60,
		0, 644, 678, 3, 200, 100, 0, 645, 678, 3, 12, 6, 0, 646, 678, 3, 148, 74,
		0, 647, 678, 3, 146, 73, 0, 648, 678, 3, 150, 75, 0, 649, 678, 3, 174,
		87, 0, 650, 678, 3, 152, 76, 0, 651, 678, 3, 180, 90, 0, 652, 678, 3, 154,
		77, 0, 653, 678, 3, 156, 78, 0, 654, 678, 3, 158, 79, 0, 655, 678, 3, 160,
		80, 0, 656, 678, 3, 162, 81, 0, 657, 678, 3, 164, 82, 0, 658, 678, 3, 166,
		83, 0, 659, 678, 3, 168, 84, 0, 660, 678, 3, 170, 85, 0, 661, 678, 3, 178,
		89, 0, 662, 678, 3, 172, 86, 0, 663, 678, 3, 176, 88, 0, 664, 678, 3, 182,
		91, 0, 665, 678, 3, 184, 92, 0, 666, 678, 3, 186, 93, 0, 667, 678, 3, 188,
		94, 0, 668, 678, 3, 190, 95, 0, 669, 678, 3, 192, 96, 0, 670, 678, 3, 194,
		97, 0, 671, 678, 3, 196, 98, 0, 672, 678, 3, 198, 99, 0, 673, 674, 5, 16,
		0, 0, 674, 675, 3, 134, 67, 0, 675, 676, 5, 17, 0, 0, 676, 678, 1, 0, 0,
		0, 677, 642, 1, 0, 0, 0, 677, 643, 1, 0, 0, 0, 677, 644, 1, 0, 0, 0, 677,
		645, 1, 0, 0, 0, 677, 646, 1, 0, 0, 0, 677, 647, 1, 0, 0, 0, 677, 648,
		1, 0, 0, 0, 677, 649, 1, 0, 0, 0, 677, 650, 1, 0, 0, 0, 677, 651, 1, 0,
		0, 0, 677, 652, 1, 0, 0, 0, 677, 653, 1, 0, 0, 0, 677, 654, 1, 0, 0, 0,
		677, 655, 1, 0, 0, 0, 677, 656, 1, 0, 0, 0, 677, 657, 1, 0, 0, 0, 677,
		658, 1, 0, 0, 0, 677, 659, 1, 0, 0, 0, 677, 660, 1, 0, 0, 0, 677, 661,
		1, 0, 0, 0, 677, 662, 1, 0, 0, 0, 677, 663, 1, 0, 0, 0, 677, 664, 1, 0,
		0, 0, 677, 665, 1, 0, 0, 0, 677, 666, 1, 0, 0, 0, 677, 667, 1, 0, 0, 0,
		677, 668, 1, 0, 0, 0, 677, 669, 1, 0, 0, 0, 677, 670, 1, 0, 0, 0, 677,
		671, 1, 0, 0, 0, 677, 672, 1, 0, 0, 0, 677, 673, 1, 0, 0, 0, 678, 123,
		1, 0, 0, 0, 679, 681, 5, 110, 0, 0, 680, 679, 1, 0, 0, 0, 680, 681, 1,
		0, 0, 0, 681, 683, 1, 0, 0, 0, 682, 684, 7, 2, 0, 0, 683, 682, 1, 0, 0,
		0, 683, 684, 1, 0, 0, 0, 684, 685, 1, 0, 0, 0, 685, 686, 3, 122, 61, 0,
		686, 125, 1, 0, 0, 0, 687, 692, 3, 124, 62, 0, 688, 689, 5, 107, 0, 0,
		689, 691, 3, 124, 62, 0, 690, 688, 1, 0, 0, 0, 691, 694, 1, 0, 0, 0, 692,
		690, 1, 0, 0, 0, 692, 693, 1, 0, 0, 0, 693, 127, 1, 0, 0, 0, 694, 692,
		1, 0, 0, 0, 695, 700, 3, 126, 63, 0, 696, 697, 7, 4, 0, 0, 697, 699, 3,
		126, 63, 0, 698, 696, 1, 0, 0, 0, 699, 702, 1, 0, 0, 0, 700, 698, 1, 0,
		0, 0, 700, 701, 1, 0, 0, 0, 701, 129, 1, 0, 0, 0, 702, 700, 1, 0, 0, 0,
		703, 708, 3, 128, 64, 0, 704, 705, 7, 2, 0, 0, 705, 707, 3, 128, 64, 0,
		706, 704, 1, 0, 0, 0, 707, 710, 1, 0, 0, 0, 708, 706, 1, 0, 0, 0, 708,
		709, 1, 0, 0, 0, 709, 131, 1, 0, 0, 0, 710, 708, 1, 0, 0, 0, 711, 715,
		3, 130, 65, 0, 712, 713, 3, 24, 12, 0, 713, 714, 3, 130, 65, 0, 714, 716,
		1, 0, 0, 0, 715, 712, 1, 0, 0, 0, 715, 716, 1, 0, 0, 0, 716, 133, 1, 0,
		0, 0, 717, 727, 3, 122, 61, 0, 718, 723, 3, 132, 66, 0, 719, 720, 7, 5,
		0, 0, 720, 722, 3, 132, 66, 0, 721, 719, 1, 0, 0, 0, 722, 725, 1, 0, 0,
		0, 723, 721, 1, 0, 0, 0, 723, 724, 1, 0, 0, 0, 724, 727, 1, 0, 0, 0, 725,
		723, 1, 0, 0, 0, 726, 717, 1, 0, 0, 0, 726, 718, 1, 0, 0, 0, 727, 135,
		1, 0, 0, 0, 728, 730, 3, 138, 69, 0, 729, 731, 3, 140, 70, 0, 730, 729,
		1, 0, 0, 0, 730, 731, 1, 0, 0, 0, 731, 137, 1, 0, 0, 0, 732, 736, 5, 119,
		0, 0, 733, 735, 7, 6, 0, 0, 734, 733, 1, 0, 0, 0, 735, 738, 1, 0, 0, 0,
		736, 734, 1, 0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 139, 1, 0, 0, 0, 738,
		736, 1, 0, 0, 0, 739, 740, 7, 7, 0, 0, 740, 141, 1, 0, 0, 0, 741, 746,
		3, 12, 6, 0, 742, 743, 5, 27, 0, 0, 743, 745, 3, 12, 6, 0, 744, 742, 1,
		0, 0, 0, 745, 748, 1, 0, 0, 0, 746, 744, 1, 0, 0, 0, 746, 747, 1, 0, 0,
		0, 747, 143, 1, 0, 0, 0, 748, 746, 1, 0, 0, 0, 749, 754, 3, 134, 67, 0,
		750, 751, 5, 27, 0, 0, 751, 753, 3, 134, 67, 0, 752, 750, 1, 0, 0, 0, 753,
		756, 1, 0, 0, 0, 754, 752, 1, 0, 0, 0, 754, 755, 1, 0, 0, 0, 755, 145,
		1, 0, 0, 0, 756, 754, 1, 0, 0, 0, 757, 758, 5, 39, 0, 0, 758, 759, 5, 16,
		0, 0, 759, 760, 3, 134, 67, 0, 760, 761, 5, 17, 0, 0, 761, 147, 1, 0, 0,
		0, 762, 763, 5, 11, 0, 0, 763, 764, 5, 16, 0, 0, 764, 765, 3, 134, 67,
		0, 765, 766, 5, 17, 0, 0, 766, 149, 1, 0, 0, 0, 767, 768, 5, 44, 0, 0,
		768, 769, 5, 16, 0, 0, 769, 770, 3, 134, 67, 0, 770, 771, 5, 17, 0, 0,
		771, 151, 1, 0, 0, 0, 772, 773, 5, 46, 0, 0, 773, 774, 5, 16, 0, 0, 774,
		775, 3, 134, 67, 0, 775, 776, 5, 17, 0, 0, 776, 153, 1, 0, 0, 0, 777, 778,
		5, 12, 0, 0, 778, 779, 5, 16, 0, 0, 779, 780, 3, 134, 67, 0, 780, 781,
		5, 27, 0, 0, 781, 782, 3, 134, 67, 0, 782, 783, 5, 27, 0, 0, 783, 784,
		3, 134, 67, 0, 784, 785, 5, 17, 0, 0, 785, 155, 1, 0, 0, 0, 786, 787, 5,
		55, 0, 0, 787, 788, 5, 16, 0, 0, 788, 789, 3, 134, 67, 0, 789, 790, 5,
		17, 0, 0, 790, 157, 1, 0, 0, 0, 791, 792, 5, 57, 0, 0, 792, 793, 5, 16,
		0, 0, 793, 794, 3, 134, 67, 0, 794, 795, 5, 17, 0, 0, 795, 159, 1, 0, 0,
		0, 796, 797, 5, 59, 0, 0, 797, 798, 5, 16, 0, 0, 798, 799, 3, 134, 67,
		0, 799, 800, 5, 17, 0, 0, 800, 161, 1, 0, 0, 0, 801, 802, 5, 67, 0, 0,
		802, 803, 5, 16, 0, 0, 803, 804, 3, 134, 67, 0, 804, 805, 5, 17, 0, 0,
		805, 163, 1, 0, 0, 0, 806, 807, 5, 68, 0, 0, 807, 808, 5, 16, 0, 0, 808,
		809, 3, 134, 67, 0, 809, 810, 5, 17, 0, 0, 810, 165, 1, 0, 0, 0, 811, 812,
		5, 69, 0, 0, 812, 813, 5, 16, 0, 0, 813, 814, 3, 134, 67, 0, 814, 815,
		5, 17, 0, 0, 815, 167, 1, 0, 0, 0, 816, 817, 5, 70, 0, 0, 817, 818, 5,
		16, 0, 0, 818, 819, 3, 134, 67, 0, 819, 820, 5, 17, 0, 0, 820, 169, 1,
		0, 0, 0, 821, 822, 5, 13, 0, 0, 822, 823, 5, 16, 0, 0, 823, 824, 3, 134,
		67, 0, 824, 825, 5, 27, 0, 0, 825, 826, 3, 134, 67, 0, 826, 827, 5, 17,
		0, 0, 827, 171, 1, 0, 0, 0, 828, 829, 5, 14, 0, 0, 829, 830, 5, 16, 0,
		0, 830, 831, 3, 134, 67, 0, 831, 832, 5, 27, 0, 0, 832, 833, 3, 134, 67,
		0, 833, 834, 5, 17, 0, 0, 834, 173, 1, 0, 0, 0, 835, 836, 5, 15, 0, 0,
		836, 837, 5, 16, 0, 0, 837, 838, 3, 134, 67, 0, 838, 839, 5, 17, 0, 0,
		839, 175, 1, 0, 0, 0, 840, 841, 5, 82, 0, 0, 841, 842, 3, 136, 68, 0, 842,
		843, 5, 16, 0, 0, 843, 844, 3, 134, 67, 0, 844, 845, 5, 17, 0, 0, 845,
		177, 1, 0, 0, 0, 846, 847, 5, 83, 0, 0, 847, 848, 5, 16, 0, 0, 848, 849,
		3, 134, 67, 0, 849, 850, 5, 17, 0, 0, 850, 179, 1, 0, 0, 0, 851, 852, 5,
		92, 0, 0, 852, 853, 5, 16, 0, 0, 853, 854, 3, 134, 67, 0, 854, 855, 5,
		27, 0, 0, 855, 856, 3, 134, 67, 0, 856, 857, 5, 17, 0, 0, 857, 181, 1,
		0, 0, 0, 858, 859, 5, 95, 0, 0, 859, 860, 5, 16, 0, 0, 860, 861, 3, 134,
		67, 0, 861, 862, 5, 17, 0, 0, 862, 183, 1, 0, 0, 0, 863, 864, 5, 96, 0,
		0, 864, 865, 5, 16, 0, 0, 865, 866, 3, 134, 67, 0, 866, 867, 5, 17, 0,
		0, 867, 185, 1, 0, 0, 0, 868, 869, 5, 97, 0, 0, 869, 870, 5, 16, 0, 0,
		870, 871, 3, 134, 67, 0, 871, 872, 5, 17, 0, 0, 872, 187, 1, 0, 0, 0, 873,
		874, 5, 98, 0, 0, 874, 875, 5, 16, 0, 0, 875, 876, 3, 134, 67, 0, 876,
		877, 5, 17, 0, 0, 877, 189, 1, 0, 0, 0, 878, 879, 5, 99, 0, 0, 879, 880,
		5, 16, 0, 0, 880, 881, 3, 134, 67, 0, 881, 882, 5, 17, 0, 0, 882, 191,
		1, 0, 0, 0, 883, 884, 5, 100, 0, 0, 884, 885, 5, 16, 0, 0, 885, 886, 3,
		134, 67, 0, 886, 887, 5, 17, 0, 0, 887, 193, 1, 0, 0, 0, 888, 889, 5, 101,
		0, 0, 889, 890, 5, 16, 0, 0, 890, 891, 3, 134, 67, 0, 891, 892, 5, 17,
		0, 0, 892, 195, 1, 0, 0, 0, 893, 894, 5, 102, 0, 0, 894, 895, 5, 16, 0,
		0, 895, 896, 3, 134, 67, 0, 896, 897, 5, 17, 0, 0, 897, 197, 1, 0, 0, 0,
		898, 899, 5, 103, 0, 0, 899, 900, 5, 16, 0, 0, 900, 901, 3, 134, 67, 0,
		901, 902, 5, 17, 0, 0, 902, 199, 1, 0, 0, 0, 903, 904, 5, 84, 0, 0, 904,
		905, 5, 16, 0, 0, 905, 906, 3, 134, 67, 0, 906, 907, 5, 17, 0, 0, 907,
		201, 1, 0, 0, 0, 51, 205, 213, 217, 222, 229, 234, 301, 310, 315, 320,
		324, 331, 353, 361, 365, 375, 380, 382, 392, 400, 403, 408, 437, 446, 454,
		463, 479, 490, 511, 515, 520, 528, 537, 546, 550, 616, 623, 638, 677, 680,
		683, 692, 700, 708, 715, 723, 726, 730, 736, 746, 754,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// BasicParserInit initializes any static state used to implement BasicParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewBasicParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func BasicParserInit() {
	staticData := &BasicParserStaticData
	staticData.once.Do(basicParserInit)
}

// NewBasicParser produces a new parser instance for the optional input antlr.TokenStream.
func NewBasicParser(input antlr.TokenStream) *BasicParser {
	BasicParserInit()
	this := new(BasicParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &BasicParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Basic.g4"

	return this
}

// BasicParser tokens.
const (
	BasicParserEOF           = antlr.TokenEOF
	BasicParserDOLLAR        = 1
	BasicParserPERCENT       = 2
	BasicParserRETURN        = 3
	BasicParserPRINT         = 4
	BasicParserGOTO          = 5
	BasicParserGOSUB         = 6
	BasicParserIF            = 7
	BasicParserNEXT          = 8
	BasicParserTHEN          = 9
	BasicParserREM           = 10
	BasicParserCHR           = 11
	BasicParserMID           = 12
	BasicParserLEFT          = 13
	BasicParserRIGHT         = 14
	BasicParserSTR           = 15
	BasicParserLPAREN        = 16
	BasicParserRPAREN        = 17
	BasicParserPLUS          = 18
	BasicParserMINUS         = 19
	BasicParserTIMES         = 20
	BasicParserDIV           = 21
	BasicParserCLEAR         = 22
	BasicParserGTE           = 23
	BasicParserLTE           = 24
	BasicParserGT            = 25
	BasicParserLT            = 26
	BasicParserCOMMA         = 27
	BasicParserLIST          = 28
	BasicParserRUN           = 29
	BasicParserEND           = 30
	BasicParserLET           = 31
	BasicParserEQ            = 32
	BasicParserFOR           = 33
	BasicParserTO            = 34
	BasicParserSTEP          = 35
	BasicParserINPUT         = 36
	BasicParserSEMICOLON     = 37
	BasicParserDIM           = 38
	BasicParserSQR           = 39
	BasicParserCOLON         = 40
	BasicParserTEXT          = 41
	BasicParserHGR           = 42
	BasicParserHGR2          = 43
	BasicParserLEN           = 44
	BasicParserCALL          = 45
	BasicParserASC           = 46
	BasicParserHPLOT         = 47
	BasicParserVPLOT         = 48
	BasicParserPRNUMBER      = 49
	BasicParserINNUMBER      = 50
	BasicParserVTAB          = 51
	BasicParserHTAB          = 52
	BasicParserHOME          = 53
	BasicParserON            = 54
	BasicParserPDL           = 55
	BasicParserPLOT          = 56
	BasicParserPEEK          = 57
	BasicParserPOKE          = 58
	BasicParserINTF          = 59
	BasicParserSTOP          = 60
	BasicParserHIMEM         = 61
	BasicParserLOMEM         = 62
	BasicParserFLASH         = 63
	BasicParserINVERSE       = 64
	BasicParserNORMAL        = 65
	BasicParserONERR         = 66
	BasicParserSPC           = 67
	BasicParserFRE           = 68
	BasicParserPOS           = 69
	BasicParserUSR           = 70
	BasicParserTRACE         = 71
	BasicParserNOTRACE       = 72
	BasicParserAND           = 73
	BasicParserOR            = 74
	BasicParserDATA          = 75
	BasicParserWAIT          = 76
	BasicParserREAD          = 77
	BasicParserXDRAW         = 78
	BasicParserDRAW          = 79
	BasicParserAT            = 80
	BasicParserDEF           = 81
	BasicParserFN            = 82
	BasicParserVAL           = 83
	BasicParserTAB           = 84
	BasicParserSPEED         = 85
	BasicParserROT           = 86
	BasicParserSCALE         = 87
	BasicParserCOLOR         = 88
	BasicParserHCOLOR        = 89
	BasicParserHLIN          = 90
	BasicParserVLIN          = 91
	BasicParserSCRN          = 92
	BasicParserPOP           = 93
	BasicParserSHLOAD        = 94
	BasicParserSIN           = 95
	BasicParserCOS           = 96
	BasicParserTAN           = 97
	BasicParserATN           = 98
	BasicParserRND           = 99
	BasicParserSGN           = 100
	BasicParserEXP           = 101
	BasicParserLOG           = 102
	BasicParserABS           = 103
	BasicParserSTORE         = 104
	BasicParserRECALL        = 105
	BasicParserGET           = 106
	BasicParserEXPONENT      = 107
	BasicParserAMPERSAND     = 108
	BasicParserGR            = 109
	BasicParserNOT           = 110
	BasicParserRESTORE       = 111
	BasicParserSAVE          = 112
	BasicParserLOAD          = 113
	BasicParserQUESTION      = 114
	BasicParserINCLUDE       = 115
	BasicParserCLS           = 116
	BasicParserCOMMENT       = 117
	BasicParserSTRINGLITERAL = 118
	BasicParserLETTERS       = 119
	BasicParserNUMBER        = 120
	BasicParserFLOAT         = 121
	BasicParserWS            = 122
)

// BasicParser rules.
const (
	BasicParserRULE_prog                  = 0
	BasicParserRULE_line                  = 1
	BasicParserRULE_amperoper             = 2
	BasicParserRULE_linenumber            = 3
	BasicParserRULE_amprstmt              = 4
	BasicParserRULE_statement             = 5
	BasicParserRULE_vardecl               = 6
	BasicParserRULE_printstmt1            = 7
	BasicParserRULE_printlist             = 8
	BasicParserRULE_getstmt               = 9
	BasicParserRULE_letstmt               = 10
	BasicParserRULE_variableassignment    = 11
	BasicParserRULE_relop                 = 12
	BasicParserRULE_neq                   = 13
	BasicParserRULE_ifstmt                = 14
	BasicParserRULE_forstmt1              = 15
	BasicParserRULE_forstmt2              = 16
	BasicParserRULE_nextstmt              = 17
	BasicParserRULE_inputstmt             = 18
	BasicParserRULE_readstmt              = 19
	BasicParserRULE_dimstmt               = 20
	BasicParserRULE_gotostmt              = 21
	BasicParserRULE_gosubstmt             = 22
	BasicParserRULE_pokestmt              = 23
	BasicParserRULE_callstmt              = 24
	BasicParserRULE_hplotstmt             = 25
	BasicParserRULE_vplotstmt             = 26
	BasicParserRULE_plotstmt              = 27
	BasicParserRULE_ongotostmt            = 28
	BasicParserRULE_ongosubstmt           = 29
	BasicParserRULE_vtabstmnt             = 30
	BasicParserRULE_htabstmnt             = 31
	BasicParserRULE_himemstmt             = 32
	BasicParserRULE_lomemstmt             = 33
	BasicParserRULE_datastmt              = 34
	BasicParserRULE_datum                 = 35
	BasicParserRULE_waitstmt              = 36
	BasicParserRULE_xdrawstmt             = 37
	BasicParserRULE_drawstmt              = 38
	BasicParserRULE_defstmt               = 39
	BasicParserRULE_tabstmt               = 40
	BasicParserRULE_speedstmt             = 41
	BasicParserRULE_rotstmt               = 42
	BasicParserRULE_scalestmt             = 43
	BasicParserRULE_colorstmt             = 44
	BasicParserRULE_hcolorstmt            = 45
	BasicParserRULE_hlinstmt              = 46
	BasicParserRULE_vlinstmt              = 47
	BasicParserRULE_onerrstmt             = 48
	BasicParserRULE_prstmt                = 49
	BasicParserRULE_instmt                = 50
	BasicParserRULE_storestmt             = 51
	BasicParserRULE_recallstmt            = 52
	BasicParserRULE_liststmt              = 53
	BasicParserRULE_popstmt               = 54
	BasicParserRULE_amptstmt              = 55
	BasicParserRULE_includestmt           = 56
	BasicParserRULE_endstmt               = 57
	BasicParserRULE_returnstmt            = 58
	BasicParserRULE_restorestmt           = 59
	BasicParserRULE_number                = 60
	BasicParserRULE_func_                 = 61
	BasicParserRULE_signExpression        = 62
	BasicParserRULE_exponentExpression    = 63
	BasicParserRULE_multiplyingExpression = 64
	BasicParserRULE_addingExpression      = 65
	BasicParserRULE_relationalExpression  = 66
	BasicParserRULE_expression            = 67
	BasicParserRULE_var_                  = 68
	BasicParserRULE_varname               = 69
	BasicParserRULE_varsuffix             = 70
	BasicParserRULE_varlist               = 71
	BasicParserRULE_exprlist              = 72
	BasicParserRULE_sqrfunc               = 73
	BasicParserRULE_chrfunc               = 74
	BasicParserRULE_lenfunc               = 75
	BasicParserRULE_ascfunc               = 76
	BasicParserRULE_midfunc               = 77
	BasicParserRULE_pdlfunc               = 78
	BasicParserRULE_peekfunc              = 79
	BasicParserRULE_intfunc               = 80
	BasicParserRULE_spcfunc               = 81
	BasicParserRULE_frefunc               = 82
	BasicParserRULE_posfunc               = 83
	BasicParserRULE_usrfunc               = 84
	BasicParserRULE_leftfunc              = 85
	BasicParserRULE_rightfunc             = 86
	BasicParserRULE_strfunc               = 87
	BasicParserRULE_fnfunc                = 88
	BasicParserRULE_valfunc               = 89
	BasicParserRULE_scrnfunc              = 90
	BasicParserRULE_sinfunc               = 91
	BasicParserRULE_cosfunc               = 92
	BasicParserRULE_tanfunc               = 93
	BasicParserRULE_atnfunc               = 94
	BasicParserRULE_rndfunc               = 95
	BasicParserRULE_sgnfunc               = 96
	BasicParserRULE_expfunc               = 97
	BasicParserRULE_logfunc               = 98
	BasicParserRULE_absfunc               = 99
	BasicParserRULE_tabfunc               = 100
)

// IProgContext is an interface to support dynamic dispatch.
type IProgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllLine() []ILineContext
	Line(i int) ILineContext

	// IsProgContext differentiates from other interfaces.
	IsProgContext()
}

type ProgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgContext() *ProgContext {
	var p = new(ProgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_prog
	return p
}

func InitEmptyProgContext(p *ProgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_prog
}

func (*ProgContext) IsProgContext() {}

func NewProgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgContext {
	var p = new(ProgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_prog

	return p
}

func (s *ProgContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgContext) EOF() antlr.TerminalNode {
	return s.GetToken(BasicParserEOF, 0)
}

func (s *ProgContext) AllLine() []ILineContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILineContext); ok {
			len++
		}
	}

	tst := make([]ILineContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILineContext); ok {
			tst[i] = t.(ILineContext)
			i++
		}
	}

	return tst
}

func (s *ProgContext) Line(i int) ILineContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILineContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILineContext)
}

func (s *ProgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitProg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Prog() (localctx IProgContext) {
	localctx = NewProgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, BasicParserRULE_prog)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == BasicParserNUMBER {
		{
			p.SetState(202)
			p.Line()
		}

		p.SetState(205)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(207)
		p.Match(BasicParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILineContext is an interface to support dynamic dispatch.
type ILineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Linenumber() ILinenumberContext
	AllAmprstmt() []IAmprstmtContext
	Amprstmt(i int) IAmprstmtContext
	COMMENT() antlr.TerminalNode
	REM() antlr.TerminalNode
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode

	// IsLineContext differentiates from other interfaces.
	IsLineContext()
}

type LineContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineContext() *LineContext {
	var p = new(LineContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_line
	return p
}

func InitEmptyLineContext(p *LineContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_line
}

func (*LineContext) IsLineContext() {}

func NewLineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineContext {
	var p = new(LineContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_line

	return p
}

func (s *LineContext) GetParser() antlr.Parser { return s.parser }

func (s *LineContext) Linenumber() ILinenumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinenumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinenumberContext)
}

func (s *LineContext) AllAmprstmt() []IAmprstmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAmprstmtContext); ok {
			len++
		}
	}

	tst := make([]IAmprstmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAmprstmtContext); ok {
			tst[i] = t.(IAmprstmtContext)
			i++
		}
	}

	return tst
}

func (s *LineContext) Amprstmt(i int) IAmprstmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAmprstmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAmprstmtContext)
}

func (s *LineContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMENT, 0)
}

func (s *LineContext) REM() antlr.TerminalNode {
	return s.GetToken(BasicParserREM, 0)
}

func (s *LineContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(BasicParserCOLON)
}

func (s *LineContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserCOLON, i)
}

func (s *LineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitLine(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Line() (localctx ILineContext) {
	localctx = NewLineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, BasicParserRULE_line)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(209)
		p.Linenumber()
	}
	p.SetState(222)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(210)
			p.Amprstmt()
		}
		p.SetState(217)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == BasicParserCOLON {
			{
				p.SetState(211)
				p.Match(BasicParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(213)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-756694541133675016) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&53962933057812871) != 0) {
				{
					p.SetState(212)
					p.Amprstmt()
				}

			}

			p.SetState(219)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(220)
			p.Match(BasicParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(221)
			p.Match(BasicParserREM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAmperoperContext is an interface to support dynamic dispatch.
type IAmperoperContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AMPERSAND() antlr.TerminalNode

	// IsAmperoperContext differentiates from other interfaces.
	IsAmperoperContext()
}

type AmperoperContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAmperoperContext() *AmperoperContext {
	var p = new(AmperoperContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_amperoper
	return p
}

func InitEmptyAmperoperContext(p *AmperoperContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_amperoper
}

func (*AmperoperContext) IsAmperoperContext() {}

func NewAmperoperContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AmperoperContext {
	var p = new(AmperoperContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_amperoper

	return p
}

func (s *AmperoperContext) GetParser() antlr.Parser { return s.parser }

func (s *AmperoperContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(BasicParserAMPERSAND, 0)
}

func (s *AmperoperContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AmperoperContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AmperoperContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitAmperoper(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Amperoper() (localctx IAmperoperContext) {
	localctx = NewAmperoperContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, BasicParserRULE_amperoper)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(224)
		p.Match(BasicParserAMPERSAND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILinenumberContext is an interface to support dynamic dispatch.
type ILinenumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUMBER() antlr.TerminalNode

	// IsLinenumberContext differentiates from other interfaces.
	IsLinenumberContext()
}

type LinenumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinenumberContext() *LinenumberContext {
	var p = new(LinenumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_linenumber
	return p
}

func InitEmptyLinenumberContext(p *LinenumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_linenumber
}

func (*LinenumberContext) IsLinenumberContext() {}

func NewLinenumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinenumberContext {
	var p = new(LinenumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_linenumber

	return p
}

func (s *LinenumberContext) GetParser() antlr.Parser { return s.parser }

func (s *LinenumberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(BasicParserNUMBER, 0)
}

func (s *LinenumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinenumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinenumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitLinenumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Linenumber() (localctx ILinenumberContext) {
	localctx = NewLinenumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, BasicParserRULE_linenumber)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(226)
		p.Match(BasicParserNUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAmprstmtContext is an interface to support dynamic dispatch.
type IAmprstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	Amperoper() IAmperoperContext
	COMMENT() antlr.TerminalNode
	REM() antlr.TerminalNode

	// IsAmprstmtContext differentiates from other interfaces.
	IsAmprstmtContext()
}

type AmprstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAmprstmtContext() *AmprstmtContext {
	var p = new(AmprstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_amprstmt
	return p
}

func InitEmptyAmprstmtContext(p *AmprstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_amprstmt
}

func (*AmprstmtContext) IsAmprstmtContext() {}

func NewAmprstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AmprstmtContext {
	var p = new(AmprstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_amprstmt

	return p
}

func (s *AmprstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AmprstmtContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *AmprstmtContext) Amperoper() IAmperoperContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAmperoperContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAmperoperContext)
}

func (s *AmprstmtContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMENT, 0)
}

func (s *AmprstmtContext) REM() antlr.TerminalNode {
	return s.GetToken(BasicParserREM, 0)
}

func (s *AmprstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AmprstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AmprstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitAmprstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Amprstmt() (localctx IAmprstmtContext) {
	localctx = NewAmprstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, BasicParserRULE_amprstmt)
	p.SetState(234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case BasicParserRETURN, BasicParserPRINT, BasicParserGOTO, BasicParserGOSUB, BasicParserIF, BasicParserNEXT, BasicParserCLEAR, BasicParserLIST, BasicParserRUN, BasicParserEND, BasicParserLET, BasicParserFOR, BasicParserINPUT, BasicParserDIM, BasicParserTEXT, BasicParserHGR, BasicParserHGR2, BasicParserCALL, BasicParserHPLOT, BasicParserVPLOT, BasicParserPRNUMBER, BasicParserINNUMBER, BasicParserVTAB, BasicParserHTAB, BasicParserHOME, BasicParserON, BasicParserPLOT, BasicParserPOKE, BasicParserSTOP, BasicParserHIMEM, BasicParserLOMEM, BasicParserFLASH, BasicParserINVERSE, BasicParserNORMAL, BasicParserONERR, BasicParserTRACE, BasicParserNOTRACE, BasicParserDATA, BasicParserWAIT, BasicParserREAD, BasicParserXDRAW, BasicParserDRAW, BasicParserDEF, BasicParserTAB, BasicParserSPEED, BasicParserROT, BasicParserSCALE, BasicParserCOLOR, BasicParserHCOLOR, BasicParserHLIN, BasicParserVLIN, BasicParserPOP, BasicParserSHLOAD, BasicParserSTORE, BasicParserRECALL, BasicParserGET, BasicParserAMPERSAND, BasicParserGR, BasicParserRESTORE, BasicParserSAVE, BasicParserLOAD, BasicParserQUESTION, BasicParserINCLUDE, BasicParserCLS, BasicParserLETTERS:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(229)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(228)
				p.Amperoper()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(231)
			p.Statement()
		}

	case BasicParserCOMMENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(232)
			p.Match(BasicParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case BasicParserREM:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(233)
			p.Match(BasicParserREM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLS() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	SAVE() antlr.TerminalNode
	TRACE() antlr.TerminalNode
	NOTRACE() antlr.TerminalNode
	FLASH() antlr.TerminalNode
	INVERSE() antlr.TerminalNode
	GR() antlr.TerminalNode
	NORMAL() antlr.TerminalNode
	SHLOAD() antlr.TerminalNode
	CLEAR() antlr.TerminalNode
	RUN() antlr.TerminalNode
	STOP() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	HOME() antlr.TerminalNode
	HGR() antlr.TerminalNode
	HGR2() antlr.TerminalNode
	Endstmt() IEndstmtContext
	Returnstmt() IReturnstmtContext
	Restorestmt() IRestorestmtContext
	Amptstmt() IAmptstmtContext
	Popstmt() IPopstmtContext
	Liststmt() IListstmtContext
	Storestmt() IStorestmtContext
	Getstmt() IGetstmtContext
	Recallstmt() IRecallstmtContext
	Nextstmt() INextstmtContext
	Instmt() IInstmtContext
	Prstmt() IPrstmtContext
	Onerrstmt() IOnerrstmtContext
	Hlinstmt() IHlinstmtContext
	Vlinstmt() IVlinstmtContext
	Colorstmt() IColorstmtContext
	Speedstmt() ISpeedstmtContext
	Scalestmt() IScalestmtContext
	Rotstmt() IRotstmtContext
	Hcolorstmt() IHcolorstmtContext
	Himemstmt() IHimemstmtContext
	Lomemstmt() ILomemstmtContext
	Printstmt1() IPrintstmt1Context
	Pokestmt() IPokestmtContext
	Plotstmt() IPlotstmtContext
	Ongotostmt() IOngotostmtContext
	Ongosubstmt() IOngosubstmtContext
	Ifstmt() IIfstmtContext
	Forstmt1() IForstmt1Context
	Forstmt2() IForstmt2Context
	Inputstmt() IInputstmtContext
	Tabstmt() ITabstmtContext
	Dimstmt() IDimstmtContext
	Gotostmt() IGotostmtContext
	Gosubstmt() IGosubstmtContext
	Callstmt() ICallstmtContext
	Readstmt() IReadstmtContext
	Hplotstmt() IHplotstmtContext
	Vplotstmt() IVplotstmtContext
	Vtabstmnt() IVtabstmntContext
	Htabstmnt() IHtabstmntContext
	Waitstmt() IWaitstmtContext
	Datastmt() IDatastmtContext
	Xdrawstmt() IXdrawstmtContext
	Drawstmt() IDrawstmtContext
	Defstmt() IDefstmtContext
	Letstmt() ILetstmtContext
	Includestmt() IIncludestmtContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CLS() antlr.TerminalNode {
	return s.GetToken(BasicParserCLS, 0)
}

func (s *StatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(BasicParserLOAD, 0)
}

func (s *StatementContext) SAVE() antlr.TerminalNode {
	return s.GetToken(BasicParserSAVE, 0)
}

func (s *StatementContext) TRACE() antlr.TerminalNode {
	return s.GetToken(BasicParserTRACE, 0)
}

func (s *StatementContext) NOTRACE() antlr.TerminalNode {
	return s.GetToken(BasicParserNOTRACE, 0)
}

func (s *StatementContext) FLASH() antlr.TerminalNode {
	return s.GetToken(BasicParserFLASH, 0)
}

func (s *StatementContext) INVERSE() antlr.TerminalNode {
	return s.GetToken(BasicParserINVERSE, 0)
}

func (s *StatementContext) GR() antlr.TerminalNode {
	return s.GetToken(BasicParserGR, 0)
}

func (s *StatementContext) NORMAL() antlr.TerminalNode {
	return s.GetToken(BasicParserNORMAL, 0)
}

func (s *StatementContext) SHLOAD() antlr.TerminalNode {
	return s.GetToken(BasicParserSHLOAD, 0)
}

func (s *StatementContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(BasicParserCLEAR, 0)
}

func (s *StatementContext) RUN() antlr.TerminalNode {
	return s.GetToken(BasicParserRUN, 0)
}

func (s *StatementContext) STOP() antlr.TerminalNode {
	return s.GetToken(BasicParserSTOP, 0)
}

func (s *StatementContext) TEXT() antlr.TerminalNode {
	return s.GetToken(BasicParserTEXT, 0)
}

func (s *StatementContext) HOME() antlr.TerminalNode {
	return s.GetToken(BasicParserHOME, 0)
}

func (s *StatementContext) HGR() antlr.TerminalNode {
	return s.GetToken(BasicParserHGR, 0)
}

func (s *StatementContext) HGR2() antlr.TerminalNode {
	return s.GetToken(BasicParserHGR2, 0)
}

func (s *StatementContext) Endstmt() IEndstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndstmtContext)
}

func (s *StatementContext) Returnstmt() IReturnstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnstmtContext)
}

func (s *StatementContext) Restorestmt() IRestorestmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestorestmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestorestmtContext)
}

func (s *StatementContext) Amptstmt() IAmptstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAmptstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAmptstmtContext)
}

func (s *StatementContext) Popstmt() IPopstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPopstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPopstmtContext)
}

func (s *StatementContext) Liststmt() IListstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListstmtContext)
}

func (s *StatementContext) Storestmt() IStorestmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorestmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorestmtContext)
}

func (s *StatementContext) Getstmt() IGetstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGetstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGetstmtContext)
}

func (s *StatementContext) Recallstmt() IRecallstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecallstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecallstmtContext)
}

func (s *StatementContext) Nextstmt() INextstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INextstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INextstmtContext)
}

func (s *StatementContext) Instmt() IInstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstmtContext)
}

func (s *StatementContext) Prstmt() IPrstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrstmtContext)
}

func (s *StatementContext) Onerrstmt() IOnerrstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnerrstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnerrstmtContext)
}

func (s *StatementContext) Hlinstmt() IHlinstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHlinstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHlinstmtContext)
}

func (s *StatementContext) Vlinstmt() IVlinstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVlinstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVlinstmtContext)
}

func (s *StatementContext) Colorstmt() IColorstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColorstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColorstmtContext)
}

func (s *StatementContext) Speedstmt() ISpeedstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpeedstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpeedstmtContext)
}

func (s *StatementContext) Scalestmt() IScalestmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalestmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalestmtContext)
}

func (s *StatementContext) Rotstmt() IRotstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRotstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRotstmtContext)
}

func (s *StatementContext) Hcolorstmt() IHcolorstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHcolorstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHcolorstmtContext)
}

func (s *StatementContext) Himemstmt() IHimemstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHimemstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHimemstmtContext)
}

func (s *StatementContext) Lomemstmt() ILomemstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILomemstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILomemstmtContext)
}

func (s *StatementContext) Printstmt1() IPrintstmt1Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrintstmt1Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrintstmt1Context)
}

func (s *StatementContext) Pokestmt() IPokestmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPokestmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPokestmtContext)
}

func (s *StatementContext) Plotstmt() IPlotstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPlotstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPlotstmtContext)
}

func (s *StatementContext) Ongotostmt() IOngotostmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOngotostmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOngotostmtContext)
}

func (s *StatementContext) Ongosubstmt() IOngosubstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOngosubstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOngosubstmtContext)
}

func (s *StatementContext) Ifstmt() IIfstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfstmtContext)
}

func (s *StatementContext) Forstmt1() IForstmt1Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForstmt1Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForstmt1Context)
}

func (s *StatementContext) Forstmt2() IForstmt2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForstmt2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForstmt2Context)
}

func (s *StatementContext) Inputstmt() IInputstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInputstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInputstmtContext)
}

func (s *StatementContext) Tabstmt() ITabstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabstmtContext)
}

func (s *StatementContext) Dimstmt() IDimstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimstmtContext)
}

func (s *StatementContext) Gotostmt() IGotostmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGotostmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGotostmtContext)
}

func (s *StatementContext) Gosubstmt() IGosubstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGosubstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGosubstmtContext)
}

func (s *StatementContext) Callstmt() ICallstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallstmtContext)
}

func (s *StatementContext) Readstmt() IReadstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReadstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReadstmtContext)
}

func (s *StatementContext) Hplotstmt() IHplotstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHplotstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHplotstmtContext)
}

func (s *StatementContext) Vplotstmt() IVplotstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVplotstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVplotstmtContext)
}

func (s *StatementContext) Vtabstmnt() IVtabstmntContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVtabstmntContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVtabstmntContext)
}

func (s *StatementContext) Htabstmnt() IHtabstmntContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHtabstmntContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHtabstmntContext)
}

func (s *StatementContext) Waitstmt() IWaitstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitstmtContext)
}

func (s *StatementContext) Datastmt() IDatastmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatastmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatastmtContext)
}

func (s *StatementContext) Xdrawstmt() IXdrawstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXdrawstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXdrawstmtContext)
}

func (s *StatementContext) Drawstmt() IDrawstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrawstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrawstmtContext)
}

func (s *StatementContext) Defstmt() IDefstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefstmtContext)
}

func (s *StatementContext) Letstmt() ILetstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetstmtContext)
}

func (s *StatementContext) Includestmt() IIncludestmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIncludestmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIncludestmtContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, BasicParserRULE_statement)
	p.SetState(301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(236)
			p.Match(BasicParserCLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(237)
			p.Match(BasicParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(238)
			p.Match(BasicParserSAVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(239)
			p.Match(BasicParserTRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(240)
			p.Match(BasicParserNOTRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(241)
			p.Match(BasicParserFLASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(242)
			p.Match(BasicParserINVERSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(243)
			p.Match(BasicParserGR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(244)
			p.Match(BasicParserNORMAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(245)
			p.Match(BasicParserSHLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(246)
			p.Match(BasicParserCLEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(247)
			p.Match(BasicParserRUN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(248)
			p.Match(BasicParserSTOP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(249)
			p.Match(BasicParserTEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(250)
			p.Match(BasicParserHOME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(251)
			p.Match(BasicParserHGR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(252)
			p.Match(BasicParserHGR2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(253)
			p.Endstmt()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(254)
			p.Returnstmt()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(255)
			p.Restorestmt()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(256)
			p.Amptstmt()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(257)
			p.Popstmt()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(258)
			p.Liststmt()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(259)
			p.Storestmt()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(260)
			p.Getstmt()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(261)
			p.Recallstmt()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(262)
			p.Nextstmt()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(263)
			p.Instmt()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(264)
			p.Prstmt()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(265)
			p.Onerrstmt()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(266)
			p.Hlinstmt()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(267)
			p.Vlinstmt()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(268)
			p.Colorstmt()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(269)
			p.Speedstmt()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(270)
			p.Scalestmt()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(271)
			p.Rotstmt()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(272)
			p.Hcolorstmt()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(273)
			p.Himemstmt()
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(274)
			p.Lomemstmt()
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(275)
			p.Printstmt1()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(276)
			p.Pokestmt()
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(277)
			p.Plotstmt()
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(278)
			p.Ongotostmt()
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(279)
			p.Ongosubstmt()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(280)
			p.Ifstmt()
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(281)
			p.Forstmt1()
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(282)
			p.Forstmt2()
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(283)
			p.Inputstmt()
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(284)
			p.Tabstmt()
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(285)
			p.Dimstmt()
		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(286)
			p.Gotostmt()
		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(287)
			p.Gosubstmt()
		}

	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(288)
			p.Callstmt()
		}

	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(289)
			p.Readstmt()
		}

	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(290)
			p.Hplotstmt()
		}

	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(291)
			p.Vplotstmt()
		}

	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(292)
			p.Vtabstmnt()
		}

	case 58:
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(293)
			p.Htabstmnt()
		}

	case 59:
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(294)
			p.Waitstmt()
		}

	case 60:
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(295)
			p.Datastmt()
		}

	case 61:
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(296)
			p.Xdrawstmt()
		}

	case 62:
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(297)
			p.Drawstmt()
		}

	case 63:
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(298)
			p.Defstmt()
		}

	case 64:
		p.EnterOuterAlt(localctx, 64)
		{
			p.SetState(299)
			p.Letstmt()
		}

	case 65:
		p.EnterOuterAlt(localctx, 65)
		{
			p.SetState(300)
			p.Includestmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVardeclContext is an interface to support dynamic dispatch.
type IVardeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Var_() IVar_Context
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllExprlist() []IExprlistContext
	Exprlist(i int) IExprlistContext
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode

	// IsVardeclContext differentiates from other interfaces.
	IsVardeclContext()
}

type VardeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVardeclContext() *VardeclContext {
	var p = new(VardeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_vardecl
	return p
}

func InitEmptyVardeclContext(p *VardeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_vardecl
}

func (*VardeclContext) IsVardeclContext() {}

func NewVardeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VardeclContext {
	var p = new(VardeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_vardecl

	return p
}

func (s *VardeclContext) GetParser() antlr.Parser { return s.parser }

func (s *VardeclContext) Var_() IVar_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVar_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVar_Context)
}

func (s *VardeclContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(BasicParserLPAREN)
}

func (s *VardeclContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, i)
}

func (s *VardeclContext) AllExprlist() []IExprlistContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprlistContext); ok {
			len++
		}
	}

	tst := make([]IExprlistContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprlistContext); ok {
			tst[i] = t.(IExprlistContext)
			i++
		}
	}

	return tst
}

func (s *VardeclContext) Exprlist(i int) IExprlistContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprlistContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *VardeclContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(BasicParserRPAREN)
}

func (s *VardeclContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, i)
}

func (s *VardeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VardeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VardeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitVardecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Vardecl() (localctx IVardeclContext) {
	localctx = NewVardeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, BasicParserRULE_vardecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(303)
		p.Var_()
	}
	p.SetState(310)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == BasicParserLPAREN {
		{
			p.SetState(304)
			p.Match(BasicParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(305)
			p.Exprlist()
		}
		{
			p.SetState(306)
			p.Match(BasicParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrintstmt1Context is an interface to support dynamic dispatch.
type IPrintstmt1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRINT() antlr.TerminalNode
	QUESTION() antlr.TerminalNode
	Printlist() IPrintlistContext

	// IsPrintstmt1Context differentiates from other interfaces.
	IsPrintstmt1Context()
}

type Printstmt1Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrintstmt1Context() *Printstmt1Context {
	var p = new(Printstmt1Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_printstmt1
	return p
}

func InitEmptyPrintstmt1Context(p *Printstmt1Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_printstmt1
}

func (*Printstmt1Context) IsPrintstmt1Context() {}

func NewPrintstmt1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Printstmt1Context {
	var p = new(Printstmt1Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_printstmt1

	return p
}

func (s *Printstmt1Context) GetParser() antlr.Parser { return s.parser }

func (s *Printstmt1Context) PRINT() antlr.TerminalNode {
	return s.GetToken(BasicParserPRINT, 0)
}

func (s *Printstmt1Context) QUESTION() antlr.TerminalNode {
	return s.GetToken(BasicParserQUESTION, 0)
}

func (s *Printstmt1Context) Printlist() IPrintlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrintlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrintlistContext)
}

func (s *Printstmt1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Printstmt1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Printstmt1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitPrintstmt1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Printstmt1() (localctx IPrintstmt1Context) {
	localctx = NewPrintstmt1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, BasicParserRULE_printstmt1)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(313)
		_la = p.GetTokenStream().LA(1)

		if !(_la == BasicParserPRINT || _la == BasicParserQUESTION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(315)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(314)
			p.Printlist()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrintlistContext is an interface to support dynamic dispatch.
type IPrintlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode

	// IsPrintlistContext differentiates from other interfaces.
	IsPrintlistContext()
}

type PrintlistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrintlistContext() *PrintlistContext {
	var p = new(PrintlistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_printlist
	return p
}

func InitEmptyPrintlistContext(p *PrintlistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_printlist
}

func (*PrintlistContext) IsPrintlistContext() {}

func NewPrintlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrintlistContext {
	var p = new(PrintlistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_printlist

	return p
}

func (s *PrintlistContext) GetParser() antlr.Parser { return s.parser }

func (s *PrintlistContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PrintlistContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrintlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BasicParserCOMMA)
}

func (s *PrintlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, i)
}

func (s *PrintlistContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(BasicParserSEMICOLON)
}

func (s *PrintlistContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserSEMICOLON, i)
}

func (s *PrintlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrintlistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitPrintlist(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Printlist() (localctx IPrintlistContext) {
	localctx = NewPrintlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, BasicParserRULE_printlist)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(317)
		p.Expression()
	}
	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == BasicParserCOMMA || _la == BasicParserSEMICOLON {
		{
			p.SetState(318)
			_la = p.GetTokenStream().LA(1)

			if !(_la == BasicParserCOMMA || _la == BasicParserSEMICOLON) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(320)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(319)
				p.Expression()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

		p.SetState(326)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGetstmtContext is an interface to support dynamic dispatch.
type IGetstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GET() antlr.TerminalNode
	Exprlist() IExprlistContext

	// IsGetstmtContext differentiates from other interfaces.
	IsGetstmtContext()
}

type GetstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetstmtContext() *GetstmtContext {
	var p = new(GetstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_getstmt
	return p
}

func InitEmptyGetstmtContext(p *GetstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_getstmt
}

func (*GetstmtContext) IsGetstmtContext() {}

func NewGetstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetstmtContext {
	var p = new(GetstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_getstmt

	return p
}

func (s *GetstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *GetstmtContext) GET() antlr.TerminalNode {
	return s.GetToken(BasicParserGET, 0)
}

func (s *GetstmtContext) Exprlist() IExprlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *GetstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitGetstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Getstmt() (localctx IGetstmtContext) {
	localctx = NewGetstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, BasicParserRULE_getstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(327)
		p.Match(BasicParserGET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(328)
		p.Exprlist()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetstmtContext is an interface to support dynamic dispatch.
type ILetstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Variableassignment() IVariableassignmentContext
	LET() antlr.TerminalNode

	// IsLetstmtContext differentiates from other interfaces.
	IsLetstmtContext()
}

type LetstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetstmtContext() *LetstmtContext {
	var p = new(LetstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_letstmt
	return p
}

func InitEmptyLetstmtContext(p *LetstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_letstmt
}

func (*LetstmtContext) IsLetstmtContext() {}

func NewLetstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetstmtContext {
	var p = new(LetstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_letstmt

	return p
}

func (s *LetstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *LetstmtContext) Variableassignment() IVariableassignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableassignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableassignmentContext)
}

func (s *LetstmtContext) LET() antlr.TerminalNode {
	return s.GetToken(BasicParserLET, 0)
}

func (s *LetstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitLetstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Letstmt() (localctx ILetstmtContext) {
	localctx = NewLetstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, BasicParserRULE_letstmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == BasicParserLET {
		{
			p.SetState(330)
			p.Match(BasicParserLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(333)
		p.Variableassignment()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableassignmentContext is an interface to support dynamic dispatch.
type IVariableassignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Vardecl() IVardeclContext
	EQ() antlr.TerminalNode
	Exprlist() IExprlistContext

	// IsVariableassignmentContext differentiates from other interfaces.
	IsVariableassignmentContext()
}

type VariableassignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableassignmentContext() *VariableassignmentContext {
	var p = new(VariableassignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_variableassignment
	return p
}

func InitEmptyVariableassignmentContext(p *VariableassignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_variableassignment
}

func (*VariableassignmentContext) IsVariableassignmentContext() {}

func NewVariableassignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableassignmentContext {
	var p = new(VariableassignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_variableassignment

	return p
}

func (s *VariableassignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableassignmentContext) Vardecl() IVardeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVardeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVardeclContext)
}

func (s *VariableassignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(BasicParserEQ, 0)
}

func (s *VariableassignmentContext) Exprlist() IExprlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *VariableassignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableassignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableassignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitVariableassignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Variableassignment() (localctx IVariableassignmentContext) {
	localctx = NewVariableassignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, BasicParserRULE_variableassignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(335)
		p.Vardecl()
	}
	{
		p.SetState(336)
		p.Match(BasicParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(337)
		p.Exprlist()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelopContext is an interface to support dynamic dispatch.
type IRelopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GTE() antlr.TerminalNode
	GT() antlr.TerminalNode
	EQ() antlr.TerminalNode
	LTE() antlr.TerminalNode
	LT() antlr.TerminalNode
	Neq() INeqContext

	// IsRelopContext differentiates from other interfaces.
	IsRelopContext()
}

type RelopContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelopContext() *RelopContext {
	var p = new(RelopContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_relop
	return p
}

func InitEmptyRelopContext(p *RelopContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_relop
}

func (*RelopContext) IsRelopContext() {}

func NewRelopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelopContext {
	var p = new(RelopContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_relop

	return p
}

func (s *RelopContext) GetParser() antlr.Parser { return s.parser }

func (s *RelopContext) GTE() antlr.TerminalNode {
	return s.GetToken(BasicParserGTE, 0)
}

func (s *RelopContext) GT() antlr.TerminalNode {
	return s.GetToken(BasicParserGT, 0)
}

func (s *RelopContext) EQ() antlr.TerminalNode {
	return s.GetToken(BasicParserEQ, 0)
}

func (s *RelopContext) LTE() antlr.TerminalNode {
	return s.GetToken(BasicParserLTE, 0)
}

func (s *RelopContext) LT() antlr.TerminalNode {
	return s.GetToken(BasicParserLT, 0)
}

func (s *RelopContext) Neq() INeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INeqContext)
}

func (s *RelopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitRelop(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Relop() (localctx IRelopContext) {
	localctx = NewRelopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, BasicParserRULE_relop)
	p.SetState(353)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(339)
			p.Match(BasicParserGTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(340)
			p.Match(BasicParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(341)
			p.Match(BasicParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(342)
			p.Match(BasicParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(343)
			p.Match(BasicParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(344)
			p.Match(BasicParserLTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(345)
			p.Match(BasicParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(346)
			p.Match(BasicParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(347)
			p.Match(BasicParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(348)
			p.Match(BasicParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(349)
			p.Neq()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(350)
			p.Match(BasicParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(351)
			p.Match(BasicParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(352)
			p.Match(BasicParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INeqContext is an interface to support dynamic dispatch.
type INeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode

	// IsNeqContext differentiates from other interfaces.
	IsNeqContext()
}

type NeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNeqContext() *NeqContext {
	var p = new(NeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_neq
	return p
}

func InitEmptyNeqContext(p *NeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_neq
}

func (*NeqContext) IsNeqContext() {}

func NewNeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NeqContext {
	var p = new(NeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_neq

	return p
}

func (s *NeqContext) GetParser() antlr.Parser { return s.parser }

func (s *NeqContext) LT() antlr.TerminalNode {
	return s.GetToken(BasicParserLT, 0)
}

func (s *NeqContext) GT() antlr.TerminalNode {
	return s.GetToken(BasicParserGT, 0)
}

func (s *NeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NeqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitNeq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Neq() (localctx INeqContext) {
	localctx = NewNeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, BasicParserRULE_neq)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(355)
		p.Match(BasicParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(356)
		p.Match(BasicParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfstmtContext is an interface to support dynamic dispatch.
type IIfstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Expression() IExpressionContext
	Statement() IStatementContext
	Linenumber() ILinenumberContext
	THEN() antlr.TerminalNode

	// IsIfstmtContext differentiates from other interfaces.
	IsIfstmtContext()
}

type IfstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfstmtContext() *IfstmtContext {
	var p = new(IfstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_ifstmt
	return p
}

func InitEmptyIfstmtContext(p *IfstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_ifstmt
}

func (*IfstmtContext) IsIfstmtContext() {}

func NewIfstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfstmtContext {
	var p = new(IfstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_ifstmt

	return p
}

func (s *IfstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IfstmtContext) IF() antlr.TerminalNode {
	return s.GetToken(BasicParserIF, 0)
}

func (s *IfstmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfstmtContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfstmtContext) Linenumber() ILinenumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinenumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinenumberContext)
}

func (s *IfstmtContext) THEN() antlr.TerminalNode {
	return s.GetToken(BasicParserTHEN, 0)
}

func (s *IfstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitIfstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Ifstmt() (localctx IIfstmtContext) {
	localctx = NewIfstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, BasicParserRULE_ifstmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(358)
		p.Match(BasicParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(359)
		p.Expression()
	}
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == BasicParserTHEN {
		{
			p.SetState(360)
			p.Match(BasicParserTHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case BasicParserRETURN, BasicParserPRINT, BasicParserGOTO, BasicParserGOSUB, BasicParserIF, BasicParserNEXT, BasicParserCLEAR, BasicParserLIST, BasicParserRUN, BasicParserEND, BasicParserLET, BasicParserFOR, BasicParserINPUT, BasicParserDIM, BasicParserTEXT, BasicParserHGR, BasicParserHGR2, BasicParserCALL, BasicParserHPLOT, BasicParserVPLOT, BasicParserPRNUMBER, BasicParserINNUMBER, BasicParserVTAB, BasicParserHTAB, BasicParserHOME, BasicParserON, BasicParserPLOT, BasicParserPOKE, BasicParserSTOP, BasicParserHIMEM, BasicParserLOMEM, BasicParserFLASH, BasicParserINVERSE, BasicParserNORMAL, BasicParserONERR, BasicParserTRACE, BasicParserNOTRACE, BasicParserDATA, BasicParserWAIT, BasicParserREAD, BasicParserXDRAW, BasicParserDRAW, BasicParserDEF, BasicParserTAB, BasicParserSPEED, BasicParserROT, BasicParserSCALE, BasicParserCOLOR, BasicParserHCOLOR, BasicParserHLIN, BasicParserVLIN, BasicParserPOP, BasicParserSHLOAD, BasicParserSTORE, BasicParserRECALL, BasicParserGET, BasicParserAMPERSAND, BasicParserGR, BasicParserRESTORE, BasicParserSAVE, BasicParserLOAD, BasicParserQUESTION, BasicParserINCLUDE, BasicParserCLS, BasicParserLETTERS:
		{
			p.SetState(363)
			p.Statement()
		}

	case BasicParserNUMBER:
		{
			p.SetState(364)
			p.Linenumber()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForstmt1Context is an interface to support dynamic dispatch.
type IForstmt1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	AllVardecl() []IVardeclContext
	Vardecl(i int) IVardeclContext
	EQ() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	TO() antlr.TerminalNode
	STEP() antlr.TerminalNode
	Statement() IStatementContext
	NEXT() antlr.TerminalNode

	// IsForstmt1Context differentiates from other interfaces.
	IsForstmt1Context()
}

type Forstmt1Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForstmt1Context() *Forstmt1Context {
	var p = new(Forstmt1Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_forstmt1
	return p
}

func InitEmptyForstmt1Context(p *Forstmt1Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_forstmt1
}

func (*Forstmt1Context) IsForstmt1Context() {}

func NewForstmt1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Forstmt1Context {
	var p = new(Forstmt1Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_forstmt1

	return p
}

func (s *Forstmt1Context) GetParser() antlr.Parser { return s.parser }

func (s *Forstmt1Context) FOR() antlr.TerminalNode {
	return s.GetToken(BasicParserFOR, 0)
}

func (s *Forstmt1Context) AllVardecl() []IVardeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVardeclContext); ok {
			len++
		}
	}

	tst := make([]IVardeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVardeclContext); ok {
			tst[i] = t.(IVardeclContext)
			i++
		}
	}

	return tst
}

func (s *Forstmt1Context) Vardecl(i int) IVardeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVardeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVardeclContext)
}

func (s *Forstmt1Context) EQ() antlr.TerminalNode {
	return s.GetToken(BasicParserEQ, 0)
}

func (s *Forstmt1Context) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Forstmt1Context) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Forstmt1Context) TO() antlr.TerminalNode {
	return s.GetToken(BasicParserTO, 0)
}

func (s *Forstmt1Context) STEP() antlr.TerminalNode {
	return s.GetToken(BasicParserSTEP, 0)
}

func (s *Forstmt1Context) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Forstmt1Context) NEXT() antlr.TerminalNode {
	return s.GetToken(BasicParserNEXT, 0)
}

func (s *Forstmt1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Forstmt1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Forstmt1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitForstmt1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Forstmt1() (localctx IForstmt1Context) {
	localctx = NewForstmt1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, BasicParserRULE_forstmt1)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(367)
		p.Match(BasicParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(368)
		p.Vardecl()
	}
	{
		p.SetState(369)
		p.Match(BasicParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(370)
		p.Expression()
	}
	{
		p.SetState(371)
		p.Match(BasicParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(372)
		p.Expression()
	}
	p.SetState(375)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == BasicParserSTEP {
		{
			p.SetState(373)
			p.Match(BasicParserSTEP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(374)
			p.Expression()
		}

	}
	p.SetState(382)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(377)
			p.Statement()
		}
		{
			p.SetState(378)
			p.Match(BasicParserNEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(380)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == BasicParserLETTERS {
			{
				p.SetState(379)
				p.Vardecl()
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForstmt2Context is an interface to support dynamic dispatch.
type IForstmt2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	Vardecl() IVardeclContext
	EQ() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	TO() antlr.TerminalNode
	STEP() antlr.TerminalNode

	// IsForstmt2Context differentiates from other interfaces.
	IsForstmt2Context()
}

type Forstmt2Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForstmt2Context() *Forstmt2Context {
	var p = new(Forstmt2Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_forstmt2
	return p
}

func InitEmptyForstmt2Context(p *Forstmt2Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_forstmt2
}

func (*Forstmt2Context) IsForstmt2Context() {}

func NewForstmt2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Forstmt2Context {
	var p = new(Forstmt2Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_forstmt2

	return p
}

func (s *Forstmt2Context) GetParser() antlr.Parser { return s.parser }

func (s *Forstmt2Context) FOR() antlr.TerminalNode {
	return s.GetToken(BasicParserFOR, 0)
}

func (s *Forstmt2Context) Vardecl() IVardeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVardeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVardeclContext)
}

func (s *Forstmt2Context) EQ() antlr.TerminalNode {
	return s.GetToken(BasicParserEQ, 0)
}

func (s *Forstmt2Context) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Forstmt2Context) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Forstmt2Context) TO() antlr.TerminalNode {
	return s.GetToken(BasicParserTO, 0)
}

func (s *Forstmt2Context) STEP() antlr.TerminalNode {
	return s.GetToken(BasicParserSTEP, 0)
}

func (s *Forstmt2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Forstmt2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Forstmt2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitForstmt2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Forstmt2() (localctx IForstmt2Context) {
	localctx = NewForstmt2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, BasicParserRULE_forstmt2)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(384)
		p.Match(BasicParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(385)
		p.Vardecl()
	}
	{
		p.SetState(386)
		p.Match(BasicParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(387)
		p.Expression()
	}
	{
		p.SetState(388)
		p.Match(BasicParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(389)
		p.Expression()
	}
	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == BasicParserSTEP {
		{
			p.SetState(390)
			p.Match(BasicParserSTEP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(391)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INextstmtContext is an interface to support dynamic dispatch.
type INextstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NEXT() antlr.TerminalNode
	AllVardecl() []IVardeclContext
	Vardecl(i int) IVardeclContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNextstmtContext differentiates from other interfaces.
	IsNextstmtContext()
}

type NextstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNextstmtContext() *NextstmtContext {
	var p = new(NextstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_nextstmt
	return p
}

func InitEmptyNextstmtContext(p *NextstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_nextstmt
}

func (*NextstmtContext) IsNextstmtContext() {}

func NewNextstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NextstmtContext {
	var p = new(NextstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_nextstmt

	return p
}

func (s *NextstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *NextstmtContext) NEXT() antlr.TerminalNode {
	return s.GetToken(BasicParserNEXT, 0)
}

func (s *NextstmtContext) AllVardecl() []IVardeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVardeclContext); ok {
			len++
		}
	}

	tst := make([]IVardeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVardeclContext); ok {
			tst[i] = t.(IVardeclContext)
			i++
		}
	}

	return tst
}

func (s *NextstmtContext) Vardecl(i int) IVardeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVardeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVardeclContext)
}

func (s *NextstmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BasicParserCOMMA)
}

func (s *NextstmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, i)
}

func (s *NextstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NextstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NextstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitNextstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Nextstmt() (localctx INextstmtContext) {
	localctx = NewNextstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, BasicParserRULE_nextstmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(394)
		p.Match(BasicParserNEXT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == BasicParserLETTERS {
		{
			p.SetState(395)
			p.Vardecl()
		}
		p.SetState(400)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == BasicParserCOMMA {
			{
				p.SetState(396)
				p.Match(BasicParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(397)
				p.Vardecl()
			}

			p.SetState(402)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInputstmtContext is an interface to support dynamic dispatch.
type IInputstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INPUT() antlr.TerminalNode
	Varlist() IVarlistContext
	STRINGLITERAL() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsInputstmtContext differentiates from other interfaces.
	IsInputstmtContext()
}

type InputstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInputstmtContext() *InputstmtContext {
	var p = new(InputstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_inputstmt
	return p
}

func InitEmptyInputstmtContext(p *InputstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_inputstmt
}

func (*InputstmtContext) IsInputstmtContext() {}

func NewInputstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InputstmtContext {
	var p = new(InputstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_inputstmt

	return p
}

func (s *InputstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *InputstmtContext) INPUT() antlr.TerminalNode {
	return s.GetToken(BasicParserINPUT, 0)
}

func (s *InputstmtContext) Varlist() IVarlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarlistContext)
}

func (s *InputstmtContext) STRINGLITERAL() antlr.TerminalNode {
	return s.GetToken(BasicParserSTRINGLITERAL, 0)
}

func (s *InputstmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, 0)
}

func (s *InputstmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(BasicParserSEMICOLON, 0)
}

func (s *InputstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InputstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InputstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitInputstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Inputstmt() (localctx IInputstmtContext) {
	localctx = NewInputstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, BasicParserRULE_inputstmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(405)
		p.Match(BasicParserINPUT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == BasicParserSTRINGLITERAL {
		{
			p.SetState(406)
			p.Match(BasicParserSTRINGLITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(407)
			_la = p.GetTokenStream().LA(1)

			if !(_la == BasicParserCOMMA || _la == BasicParserSEMICOLON) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(410)
		p.Varlist()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReadstmtContext is an interface to support dynamic dispatch.
type IReadstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	Varlist() IVarlistContext

	// IsReadstmtContext differentiates from other interfaces.
	IsReadstmtContext()
}

type ReadstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadstmtContext() *ReadstmtContext {
	var p = new(ReadstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_readstmt
	return p
}

func InitEmptyReadstmtContext(p *ReadstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_readstmt
}

func (*ReadstmtContext) IsReadstmtContext() {}

func NewReadstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadstmtContext {
	var p = new(ReadstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_readstmt

	return p
}

func (s *ReadstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadstmtContext) READ() antlr.TerminalNode {
	return s.GetToken(BasicParserREAD, 0)
}

func (s *ReadstmtContext) Varlist() IVarlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarlistContext)
}

func (s *ReadstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitReadstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Readstmt() (localctx IReadstmtContext) {
	localctx = NewReadstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, BasicParserRULE_readstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(412)
		p.Match(BasicParserREAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(413)
		p.Varlist()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDimstmtContext is an interface to support dynamic dispatch.
type IDimstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DIM() antlr.TerminalNode
	Varlist() IVarlistContext

	// IsDimstmtContext differentiates from other interfaces.
	IsDimstmtContext()
}

type DimstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimstmtContext() *DimstmtContext {
	var p = new(DimstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_dimstmt
	return p
}

func InitEmptyDimstmtContext(p *DimstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_dimstmt
}

func (*DimstmtContext) IsDimstmtContext() {}

func NewDimstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimstmtContext {
	var p = new(DimstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_dimstmt

	return p
}

func (s *DimstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DimstmtContext) DIM() antlr.TerminalNode {
	return s.GetToken(BasicParserDIM, 0)
}

func (s *DimstmtContext) Varlist() IVarlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarlistContext)
}

func (s *DimstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitDimstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Dimstmt() (localctx IDimstmtContext) {
	localctx = NewDimstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, BasicParserRULE_dimstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(415)
		p.Match(BasicParserDIM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(416)
		p.Varlist()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGotostmtContext is an interface to support dynamic dispatch.
type IGotostmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GOTO() antlr.TerminalNode
	Linenumber() ILinenumberContext

	// IsGotostmtContext differentiates from other interfaces.
	IsGotostmtContext()
}

type GotostmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGotostmtContext() *GotostmtContext {
	var p = new(GotostmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_gotostmt
	return p
}

func InitEmptyGotostmtContext(p *GotostmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_gotostmt
}

func (*GotostmtContext) IsGotostmtContext() {}

func NewGotostmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GotostmtContext {
	var p = new(GotostmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_gotostmt

	return p
}

func (s *GotostmtContext) GetParser() antlr.Parser { return s.parser }

func (s *GotostmtContext) GOTO() antlr.TerminalNode {
	return s.GetToken(BasicParserGOTO, 0)
}

func (s *GotostmtContext) Linenumber() ILinenumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinenumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinenumberContext)
}

func (s *GotostmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GotostmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GotostmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitGotostmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Gotostmt() (localctx IGotostmtContext) {
	localctx = NewGotostmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, BasicParserRULE_gotostmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(418)
		p.Match(BasicParserGOTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(419)
		p.Linenumber()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGosubstmtContext is an interface to support dynamic dispatch.
type IGosubstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GOSUB() antlr.TerminalNode
	Expression() IExpressionContext

	// IsGosubstmtContext differentiates from other interfaces.
	IsGosubstmtContext()
}

type GosubstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGosubstmtContext() *GosubstmtContext {
	var p = new(GosubstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_gosubstmt
	return p
}

func InitEmptyGosubstmtContext(p *GosubstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_gosubstmt
}

func (*GosubstmtContext) IsGosubstmtContext() {}

func NewGosubstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GosubstmtContext {
	var p = new(GosubstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_gosubstmt

	return p
}

func (s *GosubstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *GosubstmtContext) GOSUB() antlr.TerminalNode {
	return s.GetToken(BasicParserGOSUB, 0)
}

func (s *GosubstmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GosubstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GosubstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GosubstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitGosubstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Gosubstmt() (localctx IGosubstmtContext) {
	localctx = NewGosubstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, BasicParserRULE_gosubstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(421)
		p.Match(BasicParserGOSUB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(422)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPokestmtContext is an interface to support dynamic dispatch.
type IPokestmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	POKE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	COMMA() antlr.TerminalNode

	// IsPokestmtContext differentiates from other interfaces.
	IsPokestmtContext()
}

type PokestmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPokestmtContext() *PokestmtContext {
	var p = new(PokestmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_pokestmt
	return p
}

func InitEmptyPokestmtContext(p *PokestmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_pokestmt
}

func (*PokestmtContext) IsPokestmtContext() {}

func NewPokestmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PokestmtContext {
	var p = new(PokestmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_pokestmt

	return p
}

func (s *PokestmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PokestmtContext) POKE() antlr.TerminalNode {
	return s.GetToken(BasicParserPOKE, 0)
}

func (s *PokestmtContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PokestmtContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PokestmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, 0)
}

func (s *PokestmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PokestmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PokestmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitPokestmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Pokestmt() (localctx IPokestmtContext) {
	localctx = NewPokestmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, BasicParserRULE_pokestmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(424)
		p.Match(BasicParserPOKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(425)
		p.Expression()
	}
	{
		p.SetState(426)
		p.Match(BasicParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(427)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallstmtContext is an interface to support dynamic dispatch.
type ICallstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CALL() antlr.TerminalNode
	Exprlist() IExprlistContext

	// IsCallstmtContext differentiates from other interfaces.
	IsCallstmtContext()
}

type CallstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallstmtContext() *CallstmtContext {
	var p = new(CallstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_callstmt
	return p
}

func InitEmptyCallstmtContext(p *CallstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_callstmt
}

func (*CallstmtContext) IsCallstmtContext() {}

func NewCallstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallstmtContext {
	var p = new(CallstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_callstmt

	return p
}

func (s *CallstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CallstmtContext) CALL() antlr.TerminalNode {
	return s.GetToken(BasicParserCALL, 0)
}

func (s *CallstmtContext) Exprlist() IExprlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *CallstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitCallstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Callstmt() (localctx ICallstmtContext) {
	localctx = NewCallstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, BasicParserRULE_callstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(429)
		p.Match(BasicParserCALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(430)
		p.Exprlist()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHplotstmtContext is an interface to support dynamic dispatch.
type IHplotstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HPLOT() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllTO() []antlr.TerminalNode
	TO(i int) antlr.TerminalNode

	// IsHplotstmtContext differentiates from other interfaces.
	IsHplotstmtContext()
}

type HplotstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHplotstmtContext() *HplotstmtContext {
	var p = new(HplotstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_hplotstmt
	return p
}

func InitEmptyHplotstmtContext(p *HplotstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_hplotstmt
}

func (*HplotstmtContext) IsHplotstmtContext() {}

func NewHplotstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HplotstmtContext {
	var p = new(HplotstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_hplotstmt

	return p
}

func (s *HplotstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *HplotstmtContext) HPLOT() antlr.TerminalNode {
	return s.GetToken(BasicParserHPLOT, 0)
}

func (s *HplotstmtContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *HplotstmtContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HplotstmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BasicParserCOMMA)
}

func (s *HplotstmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, i)
}

func (s *HplotstmtContext) AllTO() []antlr.TerminalNode {
	return s.GetTokens(BasicParserTO)
}

func (s *HplotstmtContext) TO(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserTO, i)
}

func (s *HplotstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HplotstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HplotstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitHplotstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Hplotstmt() (localctx IHplotstmtContext) {
	localctx = NewHplotstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, BasicParserRULE_hplotstmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(432)
		p.Match(BasicParserHPLOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(437)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(433)
			p.Expression()
		}
		{
			p.SetState(434)
			p.Match(BasicParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(435)
			p.Expression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == BasicParserTO {
		{
			p.SetState(439)
			p.Match(BasicParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(440)
			p.Expression()
		}
		{
			p.SetState(441)
			p.Match(BasicParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(442)
			p.Expression()
		}

		p.SetState(448)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVplotstmtContext is an interface to support dynamic dispatch.
type IVplotstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VPLOT() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllTO() []antlr.TerminalNode
	TO(i int) antlr.TerminalNode

	// IsVplotstmtContext differentiates from other interfaces.
	IsVplotstmtContext()
}

type VplotstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVplotstmtContext() *VplotstmtContext {
	var p = new(VplotstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_vplotstmt
	return p
}

func InitEmptyVplotstmtContext(p *VplotstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_vplotstmt
}

func (*VplotstmtContext) IsVplotstmtContext() {}

func NewVplotstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VplotstmtContext {
	var p = new(VplotstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_vplotstmt

	return p
}

func (s *VplotstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *VplotstmtContext) VPLOT() antlr.TerminalNode {
	return s.GetToken(BasicParserVPLOT, 0)
}

func (s *VplotstmtContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *VplotstmtContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VplotstmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BasicParserCOMMA)
}

func (s *VplotstmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, i)
}

func (s *VplotstmtContext) AllTO() []antlr.TerminalNode {
	return s.GetTokens(BasicParserTO)
}

func (s *VplotstmtContext) TO(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserTO, i)
}

func (s *VplotstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VplotstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VplotstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitVplotstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Vplotstmt() (localctx IVplotstmtContext) {
	localctx = NewVplotstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, BasicParserRULE_vplotstmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(449)
		p.Match(BasicParserVPLOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(454)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(450)
			p.Expression()
		}
		{
			p.SetState(451)
			p.Match(BasicParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(452)
			p.Expression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(463)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == BasicParserTO {
		{
			p.SetState(456)
			p.Match(BasicParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(457)
			p.Expression()
		}
		{
			p.SetState(458)
			p.Match(BasicParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(459)
			p.Expression()
		}

		p.SetState(465)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPlotstmtContext is an interface to support dynamic dispatch.
type IPlotstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLOT() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	COMMA() antlr.TerminalNode

	// IsPlotstmtContext differentiates from other interfaces.
	IsPlotstmtContext()
}

type PlotstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPlotstmtContext() *PlotstmtContext {
	var p = new(PlotstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_plotstmt
	return p
}

func InitEmptyPlotstmtContext(p *PlotstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_plotstmt
}

func (*PlotstmtContext) IsPlotstmtContext() {}

func NewPlotstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PlotstmtContext {
	var p = new(PlotstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_plotstmt

	return p
}

func (s *PlotstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PlotstmtContext) PLOT() antlr.TerminalNode {
	return s.GetToken(BasicParserPLOT, 0)
}

func (s *PlotstmtContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PlotstmtContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PlotstmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, 0)
}

func (s *PlotstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlotstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PlotstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitPlotstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Plotstmt() (localctx IPlotstmtContext) {
	localctx = NewPlotstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, BasicParserRULE_plotstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(466)
		p.Match(BasicParserPLOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(467)
		p.Expression()
	}
	{
		p.SetState(468)
		p.Match(BasicParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(469)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOngotostmtContext is an interface to support dynamic dispatch.
type IOngotostmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	Expression() IExpressionContext
	GOTO() antlr.TerminalNode
	AllLinenumber() []ILinenumberContext
	Linenumber(i int) ILinenumberContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsOngotostmtContext differentiates from other interfaces.
	IsOngotostmtContext()
}

type OngotostmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOngotostmtContext() *OngotostmtContext {
	var p = new(OngotostmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_ongotostmt
	return p
}

func InitEmptyOngotostmtContext(p *OngotostmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_ongotostmt
}

func (*OngotostmtContext) IsOngotostmtContext() {}

func NewOngotostmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OngotostmtContext {
	var p = new(OngotostmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_ongotostmt

	return p
}

func (s *OngotostmtContext) GetParser() antlr.Parser { return s.parser }

func (s *OngotostmtContext) ON() antlr.TerminalNode {
	return s.GetToken(BasicParserON, 0)
}

func (s *OngotostmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OngotostmtContext) GOTO() antlr.TerminalNode {
	return s.GetToken(BasicParserGOTO, 0)
}

func (s *OngotostmtContext) AllLinenumber() []ILinenumberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILinenumberContext); ok {
			len++
		}
	}

	tst := make([]ILinenumberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILinenumberContext); ok {
			tst[i] = t.(ILinenumberContext)
			i++
		}
	}

	return tst
}

func (s *OngotostmtContext) Linenumber(i int) ILinenumberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinenumberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinenumberContext)
}

func (s *OngotostmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BasicParserCOMMA)
}

func (s *OngotostmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, i)
}

func (s *OngotostmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OngotostmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OngotostmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitOngotostmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Ongotostmt() (localctx IOngotostmtContext) {
	localctx = NewOngotostmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, BasicParserRULE_ongotostmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(471)
		p.Match(BasicParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(472)
		p.Expression()
	}
	{
		p.SetState(473)
		p.Match(BasicParserGOTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(474)
		p.Linenumber()
	}
	p.SetState(479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == BasicParserCOMMA {
		{
			p.SetState(475)
			p.Match(BasicParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(476)
			p.Linenumber()
		}

		p.SetState(481)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOngosubstmtContext is an interface to support dynamic dispatch.
type IOngosubstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	Expression() IExpressionContext
	GOSUB() antlr.TerminalNode
	AllLinenumber() []ILinenumberContext
	Linenumber(i int) ILinenumberContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsOngosubstmtContext differentiates from other interfaces.
	IsOngosubstmtContext()
}

type OngosubstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOngosubstmtContext() *OngosubstmtContext {
	var p = new(OngosubstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_ongosubstmt
	return p
}

func InitEmptyOngosubstmtContext(p *OngosubstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_ongosubstmt
}

func (*OngosubstmtContext) IsOngosubstmtContext() {}

func NewOngosubstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OngosubstmtContext {
	var p = new(OngosubstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_ongosubstmt

	return p
}

func (s *OngosubstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *OngosubstmtContext) ON() antlr.TerminalNode {
	return s.GetToken(BasicParserON, 0)
}

func (s *OngosubstmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OngosubstmtContext) GOSUB() antlr.TerminalNode {
	return s.GetToken(BasicParserGOSUB, 0)
}

func (s *OngosubstmtContext) AllLinenumber() []ILinenumberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILinenumberContext); ok {
			len++
		}
	}

	tst := make([]ILinenumberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILinenumberContext); ok {
			tst[i] = t.(ILinenumberContext)
			i++
		}
	}

	return tst
}

func (s *OngosubstmtContext) Linenumber(i int) ILinenumberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinenumberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinenumberContext)
}

func (s *OngosubstmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BasicParserCOMMA)
}

func (s *OngosubstmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, i)
}

func (s *OngosubstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OngosubstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OngosubstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitOngosubstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Ongosubstmt() (localctx IOngosubstmtContext) {
	localctx = NewOngosubstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, BasicParserRULE_ongosubstmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(482)
		p.Match(BasicParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(483)
		p.Expression()
	}
	{
		p.SetState(484)
		p.Match(BasicParserGOSUB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(485)
		p.Linenumber()
	}
	p.SetState(490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == BasicParserCOMMA {
		{
			p.SetState(486)
			p.Match(BasicParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(487)
			p.Linenumber()
		}

		p.SetState(492)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVtabstmntContext is an interface to support dynamic dispatch.
type IVtabstmntContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VTAB() antlr.TerminalNode
	Expression() IExpressionContext

	// IsVtabstmntContext differentiates from other interfaces.
	IsVtabstmntContext()
}

type VtabstmntContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVtabstmntContext() *VtabstmntContext {
	var p = new(VtabstmntContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_vtabstmnt
	return p
}

func InitEmptyVtabstmntContext(p *VtabstmntContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_vtabstmnt
}

func (*VtabstmntContext) IsVtabstmntContext() {}

func NewVtabstmntContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VtabstmntContext {
	var p = new(VtabstmntContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_vtabstmnt

	return p
}

func (s *VtabstmntContext) GetParser() antlr.Parser { return s.parser }

func (s *VtabstmntContext) VTAB() antlr.TerminalNode {
	return s.GetToken(BasicParserVTAB, 0)
}

func (s *VtabstmntContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VtabstmntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VtabstmntContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VtabstmntContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitVtabstmnt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Vtabstmnt() (localctx IVtabstmntContext) {
	localctx = NewVtabstmntContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, BasicParserRULE_vtabstmnt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(493)
		p.Match(BasicParserVTAB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(494)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHtabstmntContext is an interface to support dynamic dispatch.
type IHtabstmntContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HTAB() antlr.TerminalNode
	Expression() IExpressionContext

	// IsHtabstmntContext differentiates from other interfaces.
	IsHtabstmntContext()
}

type HtabstmntContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtabstmntContext() *HtabstmntContext {
	var p = new(HtabstmntContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_htabstmnt
	return p
}

func InitEmptyHtabstmntContext(p *HtabstmntContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_htabstmnt
}

func (*HtabstmntContext) IsHtabstmntContext() {}

func NewHtabstmntContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtabstmntContext {
	var p = new(HtabstmntContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_htabstmnt

	return p
}

func (s *HtabstmntContext) GetParser() antlr.Parser { return s.parser }

func (s *HtabstmntContext) HTAB() antlr.TerminalNode {
	return s.GetToken(BasicParserHTAB, 0)
}

func (s *HtabstmntContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HtabstmntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtabstmntContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HtabstmntContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitHtabstmnt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Htabstmnt() (localctx IHtabstmntContext) {
	localctx = NewHtabstmntContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, BasicParserRULE_htabstmnt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(496)
		p.Match(BasicParserHTAB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(497)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHimemstmtContext is an interface to support dynamic dispatch.
type IHimemstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HIMEM() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsHimemstmtContext differentiates from other interfaces.
	IsHimemstmtContext()
}

type HimemstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHimemstmtContext() *HimemstmtContext {
	var p = new(HimemstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_himemstmt
	return p
}

func InitEmptyHimemstmtContext(p *HimemstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_himemstmt
}

func (*HimemstmtContext) IsHimemstmtContext() {}

func NewHimemstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HimemstmtContext {
	var p = new(HimemstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_himemstmt

	return p
}

func (s *HimemstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *HimemstmtContext) HIMEM() antlr.TerminalNode {
	return s.GetToken(BasicParserHIMEM, 0)
}

func (s *HimemstmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(BasicParserCOLON, 0)
}

func (s *HimemstmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HimemstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HimemstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HimemstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitHimemstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Himemstmt() (localctx IHimemstmtContext) {
	localctx = NewHimemstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, BasicParserRULE_himemstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(499)
		p.Match(BasicParserHIMEM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(500)
		p.Match(BasicParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(501)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILomemstmtContext is an interface to support dynamic dispatch.
type ILomemstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOMEM() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsLomemstmtContext differentiates from other interfaces.
	IsLomemstmtContext()
}

type LomemstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLomemstmtContext() *LomemstmtContext {
	var p = new(LomemstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_lomemstmt
	return p
}

func InitEmptyLomemstmtContext(p *LomemstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_lomemstmt
}

func (*LomemstmtContext) IsLomemstmtContext() {}

func NewLomemstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LomemstmtContext {
	var p = new(LomemstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_lomemstmt

	return p
}

func (s *LomemstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *LomemstmtContext) LOMEM() antlr.TerminalNode {
	return s.GetToken(BasicParserLOMEM, 0)
}

func (s *LomemstmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(BasicParserCOLON, 0)
}

func (s *LomemstmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LomemstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LomemstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LomemstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitLomemstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Lomemstmt() (localctx ILomemstmtContext) {
	localctx = NewLomemstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, BasicParserRULE_lomemstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(503)
		p.Match(BasicParserLOMEM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(504)
		p.Match(BasicParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(505)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatastmtContext is an interface to support dynamic dispatch.
type IDatastmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATA() antlr.TerminalNode
	AllDatum() []IDatumContext
	Datum(i int) IDatumContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDatastmtContext differentiates from other interfaces.
	IsDatastmtContext()
}

type DatastmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatastmtContext() *DatastmtContext {
	var p = new(DatastmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_datastmt
	return p
}

func InitEmptyDatastmtContext(p *DatastmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_datastmt
}

func (*DatastmtContext) IsDatastmtContext() {}

func NewDatastmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatastmtContext {
	var p = new(DatastmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_datastmt

	return p
}

func (s *DatastmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DatastmtContext) DATA() antlr.TerminalNode {
	return s.GetToken(BasicParserDATA, 0)
}

func (s *DatastmtContext) AllDatum() []IDatumContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDatumContext); ok {
			len++
		}
	}

	tst := make([]IDatumContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDatumContext); ok {
			tst[i] = t.(IDatumContext)
			i++
		}
	}

	return tst
}

func (s *DatastmtContext) Datum(i int) IDatumContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatumContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatumContext)
}

func (s *DatastmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BasicParserCOMMA)
}

func (s *DatastmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, i)
}

func (s *DatastmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatastmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatastmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitDatastmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Datastmt() (localctx IDatastmtContext) {
	localctx = NewDatastmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, BasicParserRULE_datastmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(507)
		p.Match(BasicParserDATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(508)
		p.Datum()
	}
	p.SetState(515)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == BasicParserCOMMA {
		{
			p.SetState(509)
			p.Match(BasicParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(511)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(510)
				p.Datum()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

		p.SetState(517)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatumContext is an interface to support dynamic dispatch.
type IDatumContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext
	STRINGLITERAL() antlr.TerminalNode

	// IsDatumContext differentiates from other interfaces.
	IsDatumContext()
}

type DatumContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatumContext() *DatumContext {
	var p = new(DatumContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_datum
	return p
}

func InitEmptyDatumContext(p *DatumContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_datum
}

func (*DatumContext) IsDatumContext() {}

func NewDatumContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatumContext {
	var p = new(DatumContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_datum

	return p
}

func (s *DatumContext) GetParser() antlr.Parser { return s.parser }

func (s *DatumContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *DatumContext) STRINGLITERAL() antlr.TerminalNode {
	return s.GetToken(BasicParserSTRINGLITERAL, 0)
}

func (s *DatumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatumContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatumContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitDatum(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Datum() (localctx IDatumContext) {
	localctx = NewDatumContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, BasicParserRULE_datum)
	p.SetState(520)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case BasicParserPLUS, BasicParserMINUS, BasicParserNUMBER, BasicParserFLOAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(518)
			p.Number()
		}

	case BasicParserSTRINGLITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(519)
			p.Match(BasicParserSTRINGLITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWaitstmtContext is an interface to support dynamic dispatch.
type IWaitstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WAIT() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWaitstmtContext differentiates from other interfaces.
	IsWaitstmtContext()
}

type WaitstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWaitstmtContext() *WaitstmtContext {
	var p = new(WaitstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_waitstmt
	return p
}

func InitEmptyWaitstmtContext(p *WaitstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_waitstmt
}

func (*WaitstmtContext) IsWaitstmtContext() {}

func NewWaitstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WaitstmtContext {
	var p = new(WaitstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_waitstmt

	return p
}

func (s *WaitstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *WaitstmtContext) WAIT() antlr.TerminalNode {
	return s.GetToken(BasicParserWAIT, 0)
}

func (s *WaitstmtContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WaitstmtContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WaitstmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BasicParserCOMMA)
}

func (s *WaitstmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, i)
}

func (s *WaitstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WaitstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WaitstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitWaitstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Waitstmt() (localctx IWaitstmtContext) {
	localctx = NewWaitstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, BasicParserRULE_waitstmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(522)
		p.Match(BasicParserWAIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(523)
		p.Expression()
	}
	{
		p.SetState(524)
		p.Match(BasicParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(525)
		p.Expression()
	}
	p.SetState(528)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == BasicParserCOMMA {
		{
			p.SetState(526)
			p.Match(BasicParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(527)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXdrawstmtContext is an interface to support dynamic dispatch.
type IXdrawstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XDRAW() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AT() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsXdrawstmtContext differentiates from other interfaces.
	IsXdrawstmtContext()
}

type XdrawstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXdrawstmtContext() *XdrawstmtContext {
	var p = new(XdrawstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_xdrawstmt
	return p
}

func InitEmptyXdrawstmtContext(p *XdrawstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_xdrawstmt
}

func (*XdrawstmtContext) IsXdrawstmtContext() {}

func NewXdrawstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XdrawstmtContext {
	var p = new(XdrawstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_xdrawstmt

	return p
}

func (s *XdrawstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *XdrawstmtContext) XDRAW() antlr.TerminalNode {
	return s.GetToken(BasicParserXDRAW, 0)
}

func (s *XdrawstmtContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *XdrawstmtContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *XdrawstmtContext) AT() antlr.TerminalNode {
	return s.GetToken(BasicParserAT, 0)
}

func (s *XdrawstmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, 0)
}

func (s *XdrawstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XdrawstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XdrawstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitXdrawstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Xdrawstmt() (localctx IXdrawstmtContext) {
	localctx = NewXdrawstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, BasicParserRULE_xdrawstmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(530)
		p.Match(BasicParserXDRAW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(531)
		p.Expression()
	}
	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == BasicParserAT {
		{
			p.SetState(532)
			p.Match(BasicParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(533)
			p.Expression()
		}
		{
			p.SetState(534)
			p.Match(BasicParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(535)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrawstmtContext is an interface to support dynamic dispatch.
type IDrawstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DRAW() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AT() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsDrawstmtContext differentiates from other interfaces.
	IsDrawstmtContext()
}

type DrawstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrawstmtContext() *DrawstmtContext {
	var p = new(DrawstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_drawstmt
	return p
}

func InitEmptyDrawstmtContext(p *DrawstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_drawstmt
}

func (*DrawstmtContext) IsDrawstmtContext() {}

func NewDrawstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DrawstmtContext {
	var p = new(DrawstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_drawstmt

	return p
}

func (s *DrawstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DrawstmtContext) DRAW() antlr.TerminalNode {
	return s.GetToken(BasicParserDRAW, 0)
}

func (s *DrawstmtContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *DrawstmtContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DrawstmtContext) AT() antlr.TerminalNode {
	return s.GetToken(BasicParserAT, 0)
}

func (s *DrawstmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, 0)
}

func (s *DrawstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DrawstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DrawstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitDrawstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Drawstmt() (localctx IDrawstmtContext) {
	localctx = NewDrawstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, BasicParserRULE_drawstmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(539)
		p.Match(BasicParserDRAW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(540)
		p.Expression()
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == BasicParserAT {
		{
			p.SetState(541)
			p.Match(BasicParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(542)
			p.Expression()
		}
		{
			p.SetState(543)
			p.Match(BasicParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(544)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefstmtContext is an interface to support dynamic dispatch.
type IDefstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEF() antlr.TerminalNode
	AllVar_() []IVar_Context
	Var_(i int) IVar_Context
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	EQ() antlr.TerminalNode
	Expression() IExpressionContext
	FN() antlr.TerminalNode

	// IsDefstmtContext differentiates from other interfaces.
	IsDefstmtContext()
}

type DefstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefstmtContext() *DefstmtContext {
	var p = new(DefstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_defstmt
	return p
}

func InitEmptyDefstmtContext(p *DefstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_defstmt
}

func (*DefstmtContext) IsDefstmtContext() {}

func NewDefstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefstmtContext {
	var p = new(DefstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_defstmt

	return p
}

func (s *DefstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DefstmtContext) DEF() antlr.TerminalNode {
	return s.GetToken(BasicParserDEF, 0)
}

func (s *DefstmtContext) AllVar_() []IVar_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVar_Context); ok {
			len++
		}
	}

	tst := make([]IVar_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVar_Context); ok {
			tst[i] = t.(IVar_Context)
			i++
		}
	}

	return tst
}

func (s *DefstmtContext) Var_(i int) IVar_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVar_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVar_Context)
}

func (s *DefstmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *DefstmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *DefstmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(BasicParserEQ, 0)
}

func (s *DefstmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefstmtContext) FN() antlr.TerminalNode {
	return s.GetToken(BasicParserFN, 0)
}

func (s *DefstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitDefstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Defstmt() (localctx IDefstmtContext) {
	localctx = NewDefstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, BasicParserRULE_defstmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(548)
		p.Match(BasicParserDEF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == BasicParserFN {
		{
			p.SetState(549)
			p.Match(BasicParserFN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(552)
		p.Var_()
	}
	{
		p.SetState(553)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(554)
		p.Var_()
	}
	{
		p.SetState(555)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(556)
		p.Match(BasicParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(557)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITabstmtContext is an interface to support dynamic dispatch.
type ITabstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TAB() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsTabstmtContext differentiates from other interfaces.
	IsTabstmtContext()
}

type TabstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTabstmtContext() *TabstmtContext {
	var p = new(TabstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_tabstmt
	return p
}

func InitEmptyTabstmtContext(p *TabstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_tabstmt
}

func (*TabstmtContext) IsTabstmtContext() {}

func NewTabstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabstmtContext {
	var p = new(TabstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_tabstmt

	return p
}

func (s *TabstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *TabstmtContext) TAB() antlr.TerminalNode {
	return s.GetToken(BasicParserTAB, 0)
}

func (s *TabstmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *TabstmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TabstmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *TabstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitTabstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Tabstmt() (localctx ITabstmtContext) {
	localctx = NewTabstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, BasicParserRULE_tabstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(559)
		p.Match(BasicParserTAB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(560)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(561)
		p.Expression()
	}
	{
		p.SetState(562)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpeedstmtContext is an interface to support dynamic dispatch.
type ISpeedstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SPEED() antlr.TerminalNode
	EQ() antlr.TerminalNode
	Expression() IExpressionContext

	// IsSpeedstmtContext differentiates from other interfaces.
	IsSpeedstmtContext()
}

type SpeedstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpeedstmtContext() *SpeedstmtContext {
	var p = new(SpeedstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_speedstmt
	return p
}

func InitEmptySpeedstmtContext(p *SpeedstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_speedstmt
}

func (*SpeedstmtContext) IsSpeedstmtContext() {}

func NewSpeedstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpeedstmtContext {
	var p = new(SpeedstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_speedstmt

	return p
}

func (s *SpeedstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SpeedstmtContext) SPEED() antlr.TerminalNode {
	return s.GetToken(BasicParserSPEED, 0)
}

func (s *SpeedstmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(BasicParserEQ, 0)
}

func (s *SpeedstmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SpeedstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpeedstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpeedstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitSpeedstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Speedstmt() (localctx ISpeedstmtContext) {
	localctx = NewSpeedstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, BasicParserRULE_speedstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(564)
		p.Match(BasicParserSPEED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(565)
		p.Match(BasicParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(566)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRotstmtContext is an interface to support dynamic dispatch.
type IRotstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROT() antlr.TerminalNode
	EQ() antlr.TerminalNode
	Expression() IExpressionContext

	// IsRotstmtContext differentiates from other interfaces.
	IsRotstmtContext()
}

type RotstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRotstmtContext() *RotstmtContext {
	var p = new(RotstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_rotstmt
	return p
}

func InitEmptyRotstmtContext(p *RotstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_rotstmt
}

func (*RotstmtContext) IsRotstmtContext() {}

func NewRotstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RotstmtContext {
	var p = new(RotstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_rotstmt

	return p
}

func (s *RotstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RotstmtContext) ROT() antlr.TerminalNode {
	return s.GetToken(BasicParserROT, 0)
}

func (s *RotstmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(BasicParserEQ, 0)
}

func (s *RotstmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RotstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RotstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RotstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitRotstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Rotstmt() (localctx IRotstmtContext) {
	localctx = NewRotstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, BasicParserRULE_rotstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(568)
		p.Match(BasicParserROT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(569)
		p.Match(BasicParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(570)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalestmtContext is an interface to support dynamic dispatch.
type IScalestmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SCALE() antlr.TerminalNode
	EQ() antlr.TerminalNode
	Expression() IExpressionContext

	// IsScalestmtContext differentiates from other interfaces.
	IsScalestmtContext()
}

type ScalestmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalestmtContext() *ScalestmtContext {
	var p = new(ScalestmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_scalestmt
	return p
}

func InitEmptyScalestmtContext(p *ScalestmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_scalestmt
}

func (*ScalestmtContext) IsScalestmtContext() {}

func NewScalestmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalestmtContext {
	var p = new(ScalestmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_scalestmt

	return p
}

func (s *ScalestmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalestmtContext) SCALE() antlr.TerminalNode {
	return s.GetToken(BasicParserSCALE, 0)
}

func (s *ScalestmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(BasicParserEQ, 0)
}

func (s *ScalestmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ScalestmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalestmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalestmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitScalestmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Scalestmt() (localctx IScalestmtContext) {
	localctx = NewScalestmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, BasicParserRULE_scalestmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(572)
		p.Match(BasicParserSCALE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(573)
		p.Match(BasicParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(574)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColorstmtContext is an interface to support dynamic dispatch.
type IColorstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLOR() antlr.TerminalNode
	EQ() antlr.TerminalNode
	Expression() IExpressionContext

	// IsColorstmtContext differentiates from other interfaces.
	IsColorstmtContext()
}

type ColorstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColorstmtContext() *ColorstmtContext {
	var p = new(ColorstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_colorstmt
	return p
}

func InitEmptyColorstmtContext(p *ColorstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_colorstmt
}

func (*ColorstmtContext) IsColorstmtContext() {}

func NewColorstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColorstmtContext {
	var p = new(ColorstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_colorstmt

	return p
}

func (s *ColorstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ColorstmtContext) COLOR() antlr.TerminalNode {
	return s.GetToken(BasicParserCOLOR, 0)
}

func (s *ColorstmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(BasicParserEQ, 0)
}

func (s *ColorstmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ColorstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColorstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColorstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitColorstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Colorstmt() (localctx IColorstmtContext) {
	localctx = NewColorstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, BasicParserRULE_colorstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(576)
		p.Match(BasicParserCOLOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(577)
		p.Match(BasicParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(578)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHcolorstmtContext is an interface to support dynamic dispatch.
type IHcolorstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HCOLOR() antlr.TerminalNode
	EQ() antlr.TerminalNode
	Expression() IExpressionContext

	// IsHcolorstmtContext differentiates from other interfaces.
	IsHcolorstmtContext()
}

type HcolorstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHcolorstmtContext() *HcolorstmtContext {
	var p = new(HcolorstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_hcolorstmt
	return p
}

func InitEmptyHcolorstmtContext(p *HcolorstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_hcolorstmt
}

func (*HcolorstmtContext) IsHcolorstmtContext() {}

func NewHcolorstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HcolorstmtContext {
	var p = new(HcolorstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_hcolorstmt

	return p
}

func (s *HcolorstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *HcolorstmtContext) HCOLOR() antlr.TerminalNode {
	return s.GetToken(BasicParserHCOLOR, 0)
}

func (s *HcolorstmtContext) EQ() antlr.TerminalNode {
	return s.GetToken(BasicParserEQ, 0)
}

func (s *HcolorstmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HcolorstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HcolorstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HcolorstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitHcolorstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Hcolorstmt() (localctx IHcolorstmtContext) {
	localctx = NewHcolorstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, BasicParserRULE_hcolorstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(580)
		p.Match(BasicParserHCOLOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(581)
		p.Match(BasicParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(582)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHlinstmtContext is an interface to support dynamic dispatch.
type IHlinstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HLIN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	COMMA() antlr.TerminalNode
	AT() antlr.TerminalNode

	// IsHlinstmtContext differentiates from other interfaces.
	IsHlinstmtContext()
}

type HlinstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHlinstmtContext() *HlinstmtContext {
	var p = new(HlinstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_hlinstmt
	return p
}

func InitEmptyHlinstmtContext(p *HlinstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_hlinstmt
}

func (*HlinstmtContext) IsHlinstmtContext() {}

func NewHlinstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HlinstmtContext {
	var p = new(HlinstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_hlinstmt

	return p
}

func (s *HlinstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *HlinstmtContext) HLIN() antlr.TerminalNode {
	return s.GetToken(BasicParserHLIN, 0)
}

func (s *HlinstmtContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *HlinstmtContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HlinstmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, 0)
}

func (s *HlinstmtContext) AT() antlr.TerminalNode {
	return s.GetToken(BasicParserAT, 0)
}

func (s *HlinstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HlinstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HlinstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitHlinstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Hlinstmt() (localctx IHlinstmtContext) {
	localctx = NewHlinstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, BasicParserRULE_hlinstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(584)
		p.Match(BasicParserHLIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(585)
		p.Expression()
	}
	{
		p.SetState(586)
		p.Match(BasicParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(587)
		p.Expression()
	}
	{
		p.SetState(588)
		p.Match(BasicParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(589)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVlinstmtContext is an interface to support dynamic dispatch.
type IVlinstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VLIN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	COMMA() antlr.TerminalNode
	AT() antlr.TerminalNode

	// IsVlinstmtContext differentiates from other interfaces.
	IsVlinstmtContext()
}

type VlinstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVlinstmtContext() *VlinstmtContext {
	var p = new(VlinstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_vlinstmt
	return p
}

func InitEmptyVlinstmtContext(p *VlinstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_vlinstmt
}

func (*VlinstmtContext) IsVlinstmtContext() {}

func NewVlinstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VlinstmtContext {
	var p = new(VlinstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_vlinstmt

	return p
}

func (s *VlinstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *VlinstmtContext) VLIN() antlr.TerminalNode {
	return s.GetToken(BasicParserVLIN, 0)
}

func (s *VlinstmtContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *VlinstmtContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VlinstmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, 0)
}

func (s *VlinstmtContext) AT() antlr.TerminalNode {
	return s.GetToken(BasicParserAT, 0)
}

func (s *VlinstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VlinstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VlinstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitVlinstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Vlinstmt() (localctx IVlinstmtContext) {
	localctx = NewVlinstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, BasicParserRULE_vlinstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(591)
		p.Match(BasicParserVLIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(592)
		p.Expression()
	}
	{
		p.SetState(593)
		p.Match(BasicParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(594)
		p.Expression()
	}
	{
		p.SetState(595)
		p.Match(BasicParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(596)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOnerrstmtContext is an interface to support dynamic dispatch.
type IOnerrstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ONERR() antlr.TerminalNode
	GOTO() antlr.TerminalNode
	Linenumber() ILinenumberContext

	// IsOnerrstmtContext differentiates from other interfaces.
	IsOnerrstmtContext()
}

type OnerrstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnerrstmtContext() *OnerrstmtContext {
	var p = new(OnerrstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_onerrstmt
	return p
}

func InitEmptyOnerrstmtContext(p *OnerrstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_onerrstmt
}

func (*OnerrstmtContext) IsOnerrstmtContext() {}

func NewOnerrstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnerrstmtContext {
	var p = new(OnerrstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_onerrstmt

	return p
}

func (s *OnerrstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *OnerrstmtContext) ONERR() antlr.TerminalNode {
	return s.GetToken(BasicParserONERR, 0)
}

func (s *OnerrstmtContext) GOTO() antlr.TerminalNode {
	return s.GetToken(BasicParserGOTO, 0)
}

func (s *OnerrstmtContext) Linenumber() ILinenumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinenumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinenumberContext)
}

func (s *OnerrstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnerrstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnerrstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitOnerrstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Onerrstmt() (localctx IOnerrstmtContext) {
	localctx = NewOnerrstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, BasicParserRULE_onerrstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(598)
		p.Match(BasicParserONERR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(599)
		p.Match(BasicParserGOTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(600)
		p.Linenumber()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrstmtContext is an interface to support dynamic dispatch.
type IPrstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRNUMBER() antlr.TerminalNode
	NUMBER() antlr.TerminalNode

	// IsPrstmtContext differentiates from other interfaces.
	IsPrstmtContext()
}

type PrstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrstmtContext() *PrstmtContext {
	var p = new(PrstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_prstmt
	return p
}

func InitEmptyPrstmtContext(p *PrstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_prstmt
}

func (*PrstmtContext) IsPrstmtContext() {}

func NewPrstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrstmtContext {
	var p = new(PrstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_prstmt

	return p
}

func (s *PrstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PrstmtContext) PRNUMBER() antlr.TerminalNode {
	return s.GetToken(BasicParserPRNUMBER, 0)
}

func (s *PrstmtContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(BasicParserNUMBER, 0)
}

func (s *PrstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitPrstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Prstmt() (localctx IPrstmtContext) {
	localctx = NewPrstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, BasicParserRULE_prstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(602)
		p.Match(BasicParserPRNUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(603)
		p.Match(BasicParserNUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstmtContext is an interface to support dynamic dispatch.
type IInstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INNUMBER() antlr.TerminalNode
	NUMBER() antlr.TerminalNode

	// IsInstmtContext differentiates from other interfaces.
	IsInstmtContext()
}

type InstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstmtContext() *InstmtContext {
	var p = new(InstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_instmt
	return p
}

func InitEmptyInstmtContext(p *InstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_instmt
}

func (*InstmtContext) IsInstmtContext() {}

func NewInstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstmtContext {
	var p = new(InstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_instmt

	return p
}

func (s *InstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *InstmtContext) INNUMBER() antlr.TerminalNode {
	return s.GetToken(BasicParserINNUMBER, 0)
}

func (s *InstmtContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(BasicParserNUMBER, 0)
}

func (s *InstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitInstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Instmt() (localctx IInstmtContext) {
	localctx = NewInstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, BasicParserRULE_instmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(605)
		p.Match(BasicParserINNUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(606)
		p.Match(BasicParserNUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStorestmtContext is an interface to support dynamic dispatch.
type IStorestmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STORE() antlr.TerminalNode
	Vardecl() IVardeclContext

	// IsStorestmtContext differentiates from other interfaces.
	IsStorestmtContext()
}

type StorestmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStorestmtContext() *StorestmtContext {
	var p = new(StorestmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_storestmt
	return p
}

func InitEmptyStorestmtContext(p *StorestmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_storestmt
}

func (*StorestmtContext) IsStorestmtContext() {}

func NewStorestmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorestmtContext {
	var p = new(StorestmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_storestmt

	return p
}

func (s *StorestmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StorestmtContext) STORE() antlr.TerminalNode {
	return s.GetToken(BasicParserSTORE, 0)
}

func (s *StorestmtContext) Vardecl() IVardeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVardeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVardeclContext)
}

func (s *StorestmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorestmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StorestmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitStorestmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Storestmt() (localctx IStorestmtContext) {
	localctx = NewStorestmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, BasicParserRULE_storestmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(608)
		p.Match(BasicParserSTORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(609)
		p.Vardecl()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecallstmtContext is an interface to support dynamic dispatch.
type IRecallstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECALL() antlr.TerminalNode
	Vardecl() IVardeclContext

	// IsRecallstmtContext differentiates from other interfaces.
	IsRecallstmtContext()
}

type RecallstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecallstmtContext() *RecallstmtContext {
	var p = new(RecallstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_recallstmt
	return p
}

func InitEmptyRecallstmtContext(p *RecallstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_recallstmt
}

func (*RecallstmtContext) IsRecallstmtContext() {}

func NewRecallstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecallstmtContext {
	var p = new(RecallstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_recallstmt

	return p
}

func (s *RecallstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RecallstmtContext) RECALL() antlr.TerminalNode {
	return s.GetToken(BasicParserRECALL, 0)
}

func (s *RecallstmtContext) Vardecl() IVardeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVardeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVardeclContext)
}

func (s *RecallstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecallstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecallstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitRecallstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Recallstmt() (localctx IRecallstmtContext) {
	localctx = NewRecallstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, BasicParserRULE_recallstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(611)
		p.Match(BasicParserRECALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(612)
		p.Vardecl()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListstmtContext is an interface to support dynamic dispatch.
type IListstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIST() antlr.TerminalNode
	Expression() IExpressionContext

	// IsListstmtContext differentiates from other interfaces.
	IsListstmtContext()
}

type ListstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListstmtContext() *ListstmtContext {
	var p = new(ListstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_liststmt
	return p
}

func InitEmptyListstmtContext(p *ListstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_liststmt
}

func (*ListstmtContext) IsListstmtContext() {}

func NewListstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListstmtContext {
	var p = new(ListstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_liststmt

	return p
}

func (s *ListstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ListstmtContext) LIST() antlr.TerminalNode {
	return s.GetToken(BasicParserLIST, 0)
}

func (s *ListstmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitListstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Liststmt() (localctx IListstmtContext) {
	localctx = NewListstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, BasicParserRULE_liststmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(614)
		p.Match(BasicParserLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(616)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(615)
			p.Expression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPopstmtContext is an interface to support dynamic dispatch.
type IPopstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	POP() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	COMMA() antlr.TerminalNode

	// IsPopstmtContext differentiates from other interfaces.
	IsPopstmtContext()
}

type PopstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPopstmtContext() *PopstmtContext {
	var p = new(PopstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_popstmt
	return p
}

func InitEmptyPopstmtContext(p *PopstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_popstmt
}

func (*PopstmtContext) IsPopstmtContext() {}

func NewPopstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PopstmtContext {
	var p = new(PopstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_popstmt

	return p
}

func (s *PopstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PopstmtContext) POP() antlr.TerminalNode {
	return s.GetToken(BasicParserPOP, 0)
}

func (s *PopstmtContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PopstmtContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PopstmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, 0)
}

func (s *PopstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PopstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PopstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitPopstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Popstmt() (localctx IPopstmtContext) {
	localctx = NewPopstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, BasicParserRULE_popstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(618)
		p.Match(BasicParserPOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(623)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(619)
			p.Expression()
		}
		{
			p.SetState(620)
			p.Match(BasicParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(621)
			p.Expression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAmptstmtContext is an interface to support dynamic dispatch.
type IAmptstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AMPERSAND() antlr.TerminalNode
	Expression() IExpressionContext

	// IsAmptstmtContext differentiates from other interfaces.
	IsAmptstmtContext()
}

type AmptstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAmptstmtContext() *AmptstmtContext {
	var p = new(AmptstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_amptstmt
	return p
}

func InitEmptyAmptstmtContext(p *AmptstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_amptstmt
}

func (*AmptstmtContext) IsAmptstmtContext() {}

func NewAmptstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AmptstmtContext {
	var p = new(AmptstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_amptstmt

	return p
}

func (s *AmptstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AmptstmtContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(BasicParserAMPERSAND, 0)
}

func (s *AmptstmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AmptstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AmptstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AmptstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitAmptstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Amptstmt() (localctx IAmptstmtContext) {
	localctx = NewAmptstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, BasicParserRULE_amptstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(625)
		p.Match(BasicParserAMPERSAND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(626)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIncludestmtContext is an interface to support dynamic dispatch.
type IIncludestmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INCLUDE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsIncludestmtContext differentiates from other interfaces.
	IsIncludestmtContext()
}

type IncludestmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIncludestmtContext() *IncludestmtContext {
	var p = new(IncludestmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_includestmt
	return p
}

func InitEmptyIncludestmtContext(p *IncludestmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_includestmt
}

func (*IncludestmtContext) IsIncludestmtContext() {}

func NewIncludestmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IncludestmtContext {
	var p = new(IncludestmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_includestmt

	return p
}

func (s *IncludestmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IncludestmtContext) INCLUDE() antlr.TerminalNode {
	return s.GetToken(BasicParserINCLUDE, 0)
}

func (s *IncludestmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IncludestmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncludestmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IncludestmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitIncludestmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Includestmt() (localctx IIncludestmtContext) {
	localctx = NewIncludestmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, BasicParserRULE_includestmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(628)
		p.Match(BasicParserINCLUDE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(629)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEndstmtContext is an interface to support dynamic dispatch.
type IEndstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	END() antlr.TerminalNode

	// IsEndstmtContext differentiates from other interfaces.
	IsEndstmtContext()
}

type EndstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndstmtContext() *EndstmtContext {
	var p = new(EndstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_endstmt
	return p
}

func InitEmptyEndstmtContext(p *EndstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_endstmt
}

func (*EndstmtContext) IsEndstmtContext() {}

func NewEndstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndstmtContext {
	var p = new(EndstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_endstmt

	return p
}

func (s *EndstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *EndstmtContext) END() antlr.TerminalNode {
	return s.GetToken(BasicParserEND, 0)
}

func (s *EndstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitEndstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Endstmt() (localctx IEndstmtContext) {
	localctx = NewEndstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, BasicParserRULE_endstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(631)
		p.Match(BasicParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnstmtContext is an interface to support dynamic dispatch.
type IReturnstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode

	// IsReturnstmtContext differentiates from other interfaces.
	IsReturnstmtContext()
}

type ReturnstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnstmtContext() *ReturnstmtContext {
	var p = new(ReturnstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_returnstmt
	return p
}

func InitEmptyReturnstmtContext(p *ReturnstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_returnstmt
}

func (*ReturnstmtContext) IsReturnstmtContext() {}

func NewReturnstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnstmtContext {
	var p = new(ReturnstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_returnstmt

	return p
}

func (s *ReturnstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnstmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(BasicParserRETURN, 0)
}

func (s *ReturnstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnstmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitReturnstmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Returnstmt() (localctx IReturnstmtContext) {
	localctx = NewReturnstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, BasicParserRULE_returnstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(633)
		p.Match(BasicParserRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRestorestmtContext is an interface to support dynamic dispatch.
type IRestorestmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESTORE() antlr.TerminalNode

	// IsRestorestmtContext differentiates from other interfaces.
	IsRestorestmtContext()
}

type RestorestmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRestorestmtContext() *RestorestmtContext {
	var p = new(RestorestmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_restorestmt
	return p
}

func InitEmptyRestorestmtContext(p *RestorestmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_restorestmt
}

func (*RestorestmtContext) IsRestorestmtContext() {}

func NewRestorestmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RestorestmtContext {
	var p = new(RestorestmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_restorestmt

	return p
}

func (s *RestorestmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RestorestmtContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(BasicParserRESTORE, 0)
}

func (s *RestorestmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestorestmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RestorestmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitRestorestmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Restorestmt() (localctx IRestorestmtContext) {
	localctx = NewRestorestmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, BasicParserRULE_restorestmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(635)
		p.Match(BasicParserRESTORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUMBER() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(BasicParserNUMBER, 0)
}

func (s *NumberContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(BasicParserFLOAT, 0)
}

func (s *NumberContext) PLUS() antlr.TerminalNode {
	return s.GetToken(BasicParserPLUS, 0)
}

func (s *NumberContext) MINUS() antlr.TerminalNode {
	return s.GetToken(BasicParserMINUS, 0)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, BasicParserRULE_number)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == BasicParserPLUS || _la == BasicParserMINUS {
		{
			p.SetState(637)
			_la = p.GetTokenStream().LA(1)

			if !(_la == BasicParserPLUS || _la == BasicParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(640)
		_la = p.GetTokenStream().LA(1)

		if !(_la == BasicParserNUMBER || _la == BasicParserFLOAT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunc_Context is an interface to support dynamic dispatch.
type IFunc_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRINGLITERAL() antlr.TerminalNode
	Number() INumberContext
	Tabfunc() ITabfuncContext
	Vardecl() IVardeclContext
	Chrfunc() IChrfuncContext
	Sqrfunc() ISqrfuncContext
	Lenfunc() ILenfuncContext
	Strfunc() IStrfuncContext
	Ascfunc() IAscfuncContext
	Scrnfunc() IScrnfuncContext
	Midfunc() IMidfuncContext
	Pdlfunc() IPdlfuncContext
	Peekfunc() IPeekfuncContext
	Intfunc() IIntfuncContext
	Spcfunc() ISpcfuncContext
	Frefunc() IFrefuncContext
	Posfunc() IPosfuncContext
	Usrfunc() IUsrfuncContext
	Leftfunc() ILeftfuncContext
	Valfunc() IValfuncContext
	Rightfunc() IRightfuncContext
	Fnfunc() IFnfuncContext
	Sinfunc() ISinfuncContext
	Cosfunc() ICosfuncContext
	Tanfunc() ITanfuncContext
	Atnfunc() IAtnfuncContext
	Rndfunc() IRndfuncContext
	Sgnfunc() ISgnfuncContext
	Expfunc() IExpfuncContext
	Logfunc() ILogfuncContext
	Absfunc() IAbsfuncContext
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsFunc_Context differentiates from other interfaces.
	IsFunc_Context()
}

type Func_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_Context() *Func_Context {
	var p = new(Func_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_func_
	return p
}

func InitEmptyFunc_Context(p *Func_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_func_
}

func (*Func_Context) IsFunc_Context() {}

func NewFunc_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_Context {
	var p = new(Func_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_func_

	return p
}

func (s *Func_Context) GetParser() antlr.Parser { return s.parser }

func (s *Func_Context) STRINGLITERAL() antlr.TerminalNode {
	return s.GetToken(BasicParserSTRINGLITERAL, 0)
}

func (s *Func_Context) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Func_Context) Tabfunc() ITabfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabfuncContext)
}

func (s *Func_Context) Vardecl() IVardeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVardeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVardeclContext)
}

func (s *Func_Context) Chrfunc() IChrfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChrfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChrfuncContext)
}

func (s *Func_Context) Sqrfunc() ISqrfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqrfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqrfuncContext)
}

func (s *Func_Context) Lenfunc() ILenfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILenfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILenfuncContext)
}

func (s *Func_Context) Strfunc() IStrfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrfuncContext)
}

func (s *Func_Context) Ascfunc() IAscfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAscfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAscfuncContext)
}

func (s *Func_Context) Scrnfunc() IScrnfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScrnfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScrnfuncContext)
}

func (s *Func_Context) Midfunc() IMidfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMidfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMidfuncContext)
}

func (s *Func_Context) Pdlfunc() IPdlfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPdlfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPdlfuncContext)
}

func (s *Func_Context) Peekfunc() IPeekfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPeekfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPeekfuncContext)
}

func (s *Func_Context) Intfunc() IIntfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntfuncContext)
}

func (s *Func_Context) Spcfunc() ISpcfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpcfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpcfuncContext)
}

func (s *Func_Context) Frefunc() IFrefuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrefuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrefuncContext)
}

func (s *Func_Context) Posfunc() IPosfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPosfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPosfuncContext)
}

func (s *Func_Context) Usrfunc() IUsrfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsrfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsrfuncContext)
}

func (s *Func_Context) Leftfunc() ILeftfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftfuncContext)
}

func (s *Func_Context) Valfunc() IValfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValfuncContext)
}

func (s *Func_Context) Rightfunc() IRightfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRightfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRightfuncContext)
}

func (s *Func_Context) Fnfunc() IFnfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnfuncContext)
}

func (s *Func_Context) Sinfunc() ISinfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISinfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISinfuncContext)
}

func (s *Func_Context) Cosfunc() ICosfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICosfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICosfuncContext)
}

func (s *Func_Context) Tanfunc() ITanfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITanfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITanfuncContext)
}

func (s *Func_Context) Atnfunc() IAtnfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtnfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtnfuncContext)
}

func (s *Func_Context) Rndfunc() IRndfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRndfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRndfuncContext)
}

func (s *Func_Context) Sgnfunc() ISgnfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISgnfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISgnfuncContext)
}

func (s *Func_Context) Expfunc() IExpfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpfuncContext)
}

func (s *Func_Context) Logfunc() ILogfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogfuncContext)
}

func (s *Func_Context) Absfunc() IAbsfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbsfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbsfuncContext)
}

func (s *Func_Context) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *Func_Context) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Func_Context) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *Func_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitFunc_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Func_() (localctx IFunc_Context) {
	localctx = NewFunc_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, BasicParserRULE_func_)
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case BasicParserSTRINGLITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(642)
			p.Match(BasicParserSTRINGLITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case BasicParserPLUS, BasicParserMINUS, BasicParserNUMBER, BasicParserFLOAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(643)
			p.Number()
		}

	case BasicParserTAB:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(644)
			p.Tabfunc()
		}

	case BasicParserLETTERS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(645)
			p.Vardecl()
		}

	case BasicParserCHR:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(646)
			p.Chrfunc()
		}

	case BasicParserSQR:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(647)
			p.Sqrfunc()
		}

	case BasicParserLEN:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(648)
			p.Lenfunc()
		}

	case BasicParserSTR:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(649)
			p.Strfunc()
		}

	case BasicParserASC:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(650)
			p.Ascfunc()
		}

	case BasicParserSCRN:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(651)
			p.Scrnfunc()
		}

	case BasicParserMID:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(652)
			p.Midfunc()
		}

	case BasicParserPDL:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(653)
			p.Pdlfunc()
		}

	case BasicParserPEEK:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(654)
			p.Peekfunc()
		}

	case BasicParserINTF:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(655)
			p.Intfunc()
		}

	case BasicParserSPC:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(656)
			p.Spcfunc()
		}

	case BasicParserFRE:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(657)
			p.Frefunc()
		}

	case BasicParserPOS:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(658)
			p.Posfunc()
		}

	case BasicParserUSR:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(659)
			p.Usrfunc()
		}

	case BasicParserLEFT:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(660)
			p.Leftfunc()
		}

	case BasicParserVAL:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(661)
			p.Valfunc()
		}

	case BasicParserRIGHT:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(662)
			p.Rightfunc()
		}

	case BasicParserFN:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(663)
			p.Fnfunc()
		}

	case BasicParserSIN:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(664)
			p.Sinfunc()
		}

	case BasicParserCOS:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(665)
			p.Cosfunc()
		}

	case BasicParserTAN:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(666)
			p.Tanfunc()
		}

	case BasicParserATN:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(667)
			p.Atnfunc()
		}

	case BasicParserRND:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(668)
			p.Rndfunc()
		}

	case BasicParserSGN:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(669)
			p.Sgnfunc()
		}

	case BasicParserEXP:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(670)
			p.Expfunc()
		}

	case BasicParserLOG:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(671)
			p.Logfunc()
		}

	case BasicParserABS:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(672)
			p.Absfunc()
		}

	case BasicParserLPAREN:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(673)
			p.Match(BasicParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(674)
			p.Expression()
		}
		{
			p.SetState(675)
			p.Match(BasicParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignExpressionContext is an interface to support dynamic dispatch.
type ISignExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Func_() IFunc_Context
	NOT() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsSignExpressionContext differentiates from other interfaces.
	IsSignExpressionContext()
}

type SignExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignExpressionContext() *SignExpressionContext {
	var p = new(SignExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_signExpression
	return p
}

func InitEmptySignExpressionContext(p *SignExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_signExpression
}

func (*SignExpressionContext) IsSignExpressionContext() {}

func NewSignExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignExpressionContext {
	var p = new(SignExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_signExpression

	return p
}

func (s *SignExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SignExpressionContext) Func_() IFunc_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_Context)
}

func (s *SignExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(BasicParserNOT, 0)
}

func (s *SignExpressionContext) PLUS() antlr.TerminalNode {
	return s.GetToken(BasicParserPLUS, 0)
}

func (s *SignExpressionContext) MINUS() antlr.TerminalNode {
	return s.GetToken(BasicParserMINUS, 0)
}

func (s *SignExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitSignExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) SignExpression() (localctx ISignExpressionContext) {
	localctx = NewSignExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, BasicParserRULE_signExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == BasicParserNOT {
		{
			p.SetState(679)
			p.Match(BasicParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(683)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(682)
			_la = p.GetTokenStream().LA(1)

			if !(_la == BasicParserPLUS || _la == BasicParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(685)
		p.Func_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExponentExpressionContext is an interface to support dynamic dispatch.
type IExponentExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSignExpression() []ISignExpressionContext
	SignExpression(i int) ISignExpressionContext
	AllEXPONENT() []antlr.TerminalNode
	EXPONENT(i int) antlr.TerminalNode

	// IsExponentExpressionContext differentiates from other interfaces.
	IsExponentExpressionContext()
}

type ExponentExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExponentExpressionContext() *ExponentExpressionContext {
	var p = new(ExponentExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_exponentExpression
	return p
}

func InitEmptyExponentExpressionContext(p *ExponentExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_exponentExpression
}

func (*ExponentExpressionContext) IsExponentExpressionContext() {}

func NewExponentExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExponentExpressionContext {
	var p = new(ExponentExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_exponentExpression

	return p
}

func (s *ExponentExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExponentExpressionContext) AllSignExpression() []ISignExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISignExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISignExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISignExpressionContext); ok {
			tst[i] = t.(ISignExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExponentExpressionContext) SignExpression(i int) ISignExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignExpressionContext)
}

func (s *ExponentExpressionContext) AllEXPONENT() []antlr.TerminalNode {
	return s.GetTokens(BasicParserEXPONENT)
}

func (s *ExponentExpressionContext) EXPONENT(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserEXPONENT, i)
}

func (s *ExponentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExponentExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExponentExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitExponentExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) ExponentExpression() (localctx IExponentExpressionContext) {
	localctx = NewExponentExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, BasicParserRULE_exponentExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(687)
		p.SignExpression()
	}
	p.SetState(692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == BasicParserEXPONENT {
		{
			p.SetState(688)
			p.Match(BasicParserEXPONENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(689)
			p.SignExpression()
		}

		p.SetState(694)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplyingExpressionContext is an interface to support dynamic dispatch.
type IMultiplyingExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExponentExpression() []IExponentExpressionContext
	ExponentExpression(i int) IExponentExpressionContext
	AllTIMES() []antlr.TerminalNode
	TIMES(i int) antlr.TerminalNode
	AllDIV() []antlr.TerminalNode
	DIV(i int) antlr.TerminalNode

	// IsMultiplyingExpressionContext differentiates from other interfaces.
	IsMultiplyingExpressionContext()
}

type MultiplyingExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyingExpressionContext() *MultiplyingExpressionContext {
	var p = new(MultiplyingExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_multiplyingExpression
	return p
}

func InitEmptyMultiplyingExpressionContext(p *MultiplyingExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_multiplyingExpression
}

func (*MultiplyingExpressionContext) IsMultiplyingExpressionContext() {}

func NewMultiplyingExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyingExpressionContext {
	var p = new(MultiplyingExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_multiplyingExpression

	return p
}

func (s *MultiplyingExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyingExpressionContext) AllExponentExpression() []IExponentExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExponentExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExponentExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExponentExpressionContext); ok {
			tst[i] = t.(IExponentExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplyingExpressionContext) ExponentExpression(i int) IExponentExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExponentExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExponentExpressionContext)
}

func (s *MultiplyingExpressionContext) AllTIMES() []antlr.TerminalNode {
	return s.GetTokens(BasicParserTIMES)
}

func (s *MultiplyingExpressionContext) TIMES(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserTIMES, i)
}

func (s *MultiplyingExpressionContext) AllDIV() []antlr.TerminalNode {
	return s.GetTokens(BasicParserDIV)
}

func (s *MultiplyingExpressionContext) DIV(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserDIV, i)
}

func (s *MultiplyingExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyingExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyingExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitMultiplyingExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) MultiplyingExpression() (localctx IMultiplyingExpressionContext) {
	localctx = NewMultiplyingExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, BasicParserRULE_multiplyingExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(695)
		p.ExponentExpression()
	}
	p.SetState(700)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == BasicParserTIMES || _la == BasicParserDIV {
		{
			p.SetState(696)
			_la = p.GetTokenStream().LA(1)

			if !(_la == BasicParserTIMES || _la == BasicParserDIV) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(697)
			p.ExponentExpression()
		}

		p.SetState(702)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddingExpressionContext is an interface to support dynamic dispatch.
type IAddingExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMultiplyingExpression() []IMultiplyingExpressionContext
	MultiplyingExpression(i int) IMultiplyingExpressionContext
	AllPLUS() []antlr.TerminalNode
	PLUS(i int) antlr.TerminalNode
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode

	// IsAddingExpressionContext differentiates from other interfaces.
	IsAddingExpressionContext()
}

type AddingExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddingExpressionContext() *AddingExpressionContext {
	var p = new(AddingExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_addingExpression
	return p
}

func InitEmptyAddingExpressionContext(p *AddingExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_addingExpression
}

func (*AddingExpressionContext) IsAddingExpressionContext() {}

func NewAddingExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddingExpressionContext {
	var p = new(AddingExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_addingExpression

	return p
}

func (s *AddingExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AddingExpressionContext) AllMultiplyingExpression() []IMultiplyingExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiplyingExpressionContext); ok {
			len++
		}
	}

	tst := make([]IMultiplyingExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiplyingExpressionContext); ok {
			tst[i] = t.(IMultiplyingExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AddingExpressionContext) MultiplyingExpression(i int) IMultiplyingExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplyingExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplyingExpressionContext)
}

func (s *AddingExpressionContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(BasicParserPLUS)
}

func (s *AddingExpressionContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserPLUS, i)
}

func (s *AddingExpressionContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(BasicParserMINUS)
}

func (s *AddingExpressionContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserMINUS, i)
}

func (s *AddingExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddingExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddingExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitAddingExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) AddingExpression() (localctx IAddingExpressionContext) {
	localctx = NewAddingExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, BasicParserRULE_addingExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(703)
		p.MultiplyingExpression()
	}
	p.SetState(708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == BasicParserPLUS || _la == BasicParserMINUS {
		{
			p.SetState(704)
			_la = p.GetTokenStream().LA(1)

			if !(_la == BasicParserPLUS || _la == BasicParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(705)
			p.MultiplyingExpression()
		}

		p.SetState(710)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationalExpressionContext is an interface to support dynamic dispatch.
type IRelationalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAddingExpression() []IAddingExpressionContext
	AddingExpression(i int) IAddingExpressionContext
	Relop() IRelopContext

	// IsRelationalExpressionContext differentiates from other interfaces.
	IsRelationalExpressionContext()
}

type RelationalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationalExpressionContext() *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_relationalExpression
	return p
}

func InitEmptyRelationalExpressionContext(p *RelationalExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_relationalExpression
}

func (*RelationalExpressionContext) IsRelationalExpressionContext() {}

func NewRelationalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_relationalExpression

	return p
}

func (s *RelationalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationalExpressionContext) AllAddingExpression() []IAddingExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAddingExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAddingExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAddingExpressionContext); ok {
			tst[i] = t.(IAddingExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RelationalExpressionContext) AddingExpression(i int) IAddingExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddingExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddingExpressionContext)
}

func (s *RelationalExpressionContext) Relop() IRelopContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelopContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelopContext)
}

func (s *RelationalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitRelationalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) RelationalExpression() (localctx IRelationalExpressionContext) {
	localctx = NewRelationalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, BasicParserRULE_relationalExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(711)
		p.AddingExpression()
	}
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4420796416) != 0 {
		{
			p.SetState(712)
			p.Relop()
		}
		{
			p.SetState(713)
			p.AddingExpression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Func_() IFunc_Context
	AllRelationalExpression() []IRelationalExpressionContext
	RelationalExpression(i int) IRelationalExpressionContext
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode
	AllOR() []antlr.TerminalNode
	OR(i int) antlr.TerminalNode

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Func_() IFunc_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_Context)
}

func (s *ExpressionContext) AllRelationalExpression() []IRelationalExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationalExpressionContext); ok {
			len++
		}
	}

	tst := make([]IRelationalExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationalExpressionContext); ok {
			tst[i] = t.(IRelationalExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) RelationalExpression(i int) IRelationalExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationalExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationalExpressionContext)
}

func (s *ExpressionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(BasicParserAND)
}

func (s *ExpressionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserAND, i)
}

func (s *ExpressionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(BasicParserOR)
}

func (s *ExpressionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserOR, i)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, BasicParserRULE_expression)
	var _la int

	p.SetState(726)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(717)
			p.Func_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(718)
			p.RelationalExpression()
		}
		p.SetState(723)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == BasicParserAND || _la == BasicParserOR {
			{
				p.SetState(719)
				_la = p.GetTokenStream().LA(1)

				if !(_la == BasicParserAND || _la == BasicParserOR) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(720)
				p.RelationalExpression()
			}

			p.SetState(725)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVar_Context is an interface to support dynamic dispatch.
type IVar_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Varname() IVarnameContext
	Varsuffix() IVarsuffixContext

	// IsVar_Context differentiates from other interfaces.
	IsVar_Context()
}

type Var_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVar_Context() *Var_Context {
	var p = new(Var_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_var_
	return p
}

func InitEmptyVar_Context(p *Var_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_var_
}

func (*Var_Context) IsVar_Context() {}

func NewVar_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Var_Context {
	var p = new(Var_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_var_

	return p
}

func (s *Var_Context) GetParser() antlr.Parser { return s.parser }

func (s *Var_Context) Varname() IVarnameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarnameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarnameContext)
}

func (s *Var_Context) Varsuffix() IVarsuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarsuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarsuffixContext)
}

func (s *Var_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Var_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Var_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitVar_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Var_() (localctx IVar_Context) {
	localctx = NewVar_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, BasicParserRULE_var_)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(728)
		p.Varname()
	}
	p.SetState(730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == BasicParserDOLLAR || _la == BasicParserPERCENT {
		{
			p.SetState(729)
			p.Varsuffix()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarnameContext is an interface to support dynamic dispatch.
type IVarnameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLETTERS() []antlr.TerminalNode
	LETTERS(i int) antlr.TerminalNode
	AllNUMBER() []antlr.TerminalNode
	NUMBER(i int) antlr.TerminalNode

	// IsVarnameContext differentiates from other interfaces.
	IsVarnameContext()
}

type VarnameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarnameContext() *VarnameContext {
	var p = new(VarnameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_varname
	return p
}

func InitEmptyVarnameContext(p *VarnameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_varname
}

func (*VarnameContext) IsVarnameContext() {}

func NewVarnameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarnameContext {
	var p = new(VarnameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_varname

	return p
}

func (s *VarnameContext) GetParser() antlr.Parser { return s.parser }

func (s *VarnameContext) AllLETTERS() []antlr.TerminalNode {
	return s.GetTokens(BasicParserLETTERS)
}

func (s *VarnameContext) LETTERS(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserLETTERS, i)
}

func (s *VarnameContext) AllNUMBER() []antlr.TerminalNode {
	return s.GetTokens(BasicParserNUMBER)
}

func (s *VarnameContext) NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserNUMBER, i)
}

func (s *VarnameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarnameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarnameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitVarname(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Varname() (localctx IVarnameContext) {
	localctx = NewVarnameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, BasicParserRULE_varname)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(732)
		p.Match(BasicParserLETTERS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(733)
				_la = p.GetTokenStream().LA(1)

				if !(_la == BasicParserLETTERS || _la == BasicParserNUMBER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(738)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarsuffixContext is an interface to support dynamic dispatch.
type IVarsuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOLLAR() antlr.TerminalNode
	PERCENT() antlr.TerminalNode

	// IsVarsuffixContext differentiates from other interfaces.
	IsVarsuffixContext()
}

type VarsuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarsuffixContext() *VarsuffixContext {
	var p = new(VarsuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_varsuffix
	return p
}

func InitEmptyVarsuffixContext(p *VarsuffixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_varsuffix
}

func (*VarsuffixContext) IsVarsuffixContext() {}

func NewVarsuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarsuffixContext {
	var p = new(VarsuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_varsuffix

	return p
}

func (s *VarsuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *VarsuffixContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(BasicParserDOLLAR, 0)
}

func (s *VarsuffixContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(BasicParserPERCENT, 0)
}

func (s *VarsuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarsuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarsuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitVarsuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Varsuffix() (localctx IVarsuffixContext) {
	localctx = NewVarsuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, BasicParserRULE_varsuffix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		_la = p.GetTokenStream().LA(1)

		if !(_la == BasicParserDOLLAR || _la == BasicParserPERCENT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarlistContext is an interface to support dynamic dispatch.
type IVarlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVardecl() []IVardeclContext
	Vardecl(i int) IVardeclContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsVarlistContext differentiates from other interfaces.
	IsVarlistContext()
}

type VarlistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarlistContext() *VarlistContext {
	var p = new(VarlistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_varlist
	return p
}

func InitEmptyVarlistContext(p *VarlistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_varlist
}

func (*VarlistContext) IsVarlistContext() {}

func NewVarlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarlistContext {
	var p = new(VarlistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_varlist

	return p
}

func (s *VarlistContext) GetParser() antlr.Parser { return s.parser }

func (s *VarlistContext) AllVardecl() []IVardeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVardeclContext); ok {
			len++
		}
	}

	tst := make([]IVardeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVardeclContext); ok {
			tst[i] = t.(IVardeclContext)
			i++
		}
	}

	return tst
}

func (s *VarlistContext) Vardecl(i int) IVardeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVardeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVardeclContext)
}

func (s *VarlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BasicParserCOMMA)
}

func (s *VarlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, i)
}

func (s *VarlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarlistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitVarlist(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Varlist() (localctx IVarlistContext) {
	localctx = NewVarlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, BasicParserRULE_varlist)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(741)
		p.Vardecl()
	}
	p.SetState(746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == BasicParserCOMMA {
		{
			p.SetState(742)
			p.Match(BasicParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(743)
			p.Vardecl()
		}

		p.SetState(748)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprlistContext is an interface to support dynamic dispatch.
type IExprlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExprlistContext differentiates from other interfaces.
	IsExprlistContext()
}

type ExprlistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprlistContext() *ExprlistContext {
	var p = new(ExprlistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_exprlist
	return p
}

func InitEmptyExprlistContext(p *ExprlistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_exprlist
}

func (*ExprlistContext) IsExprlistContext() {}

func NewExprlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprlistContext {
	var p = new(ExprlistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_exprlist

	return p
}

func (s *ExprlistContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprlistContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExprlistContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExprlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BasicParserCOMMA)
}

func (s *ExprlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, i)
}

func (s *ExprlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprlistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitExprlist(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Exprlist() (localctx IExprlistContext) {
	localctx = NewExprlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, BasicParserRULE_exprlist)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(749)
		p.Expression()
	}
	p.SetState(754)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == BasicParserCOMMA {
		{
			p.SetState(750)
			p.Match(BasicParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(751)
			p.Expression()
		}

		p.SetState(756)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISqrfuncContext is an interface to support dynamic dispatch.
type ISqrfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SQR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsSqrfuncContext differentiates from other interfaces.
	IsSqrfuncContext()
}

type SqrfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqrfuncContext() *SqrfuncContext {
	var p = new(SqrfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_sqrfunc
	return p
}

func InitEmptySqrfuncContext(p *SqrfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_sqrfunc
}

func (*SqrfuncContext) IsSqrfuncContext() {}

func NewSqrfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqrfuncContext {
	var p = new(SqrfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_sqrfunc

	return p
}

func (s *SqrfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *SqrfuncContext) SQR() antlr.TerminalNode {
	return s.GetToken(BasicParserSQR, 0)
}

func (s *SqrfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *SqrfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SqrfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *SqrfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqrfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqrfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitSqrfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Sqrfunc() (localctx ISqrfuncContext) {
	localctx = NewSqrfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, BasicParserRULE_sqrfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(757)
		p.Match(BasicParserSQR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(758)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(759)
		p.Expression()
	}
	{
		p.SetState(760)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChrfuncContext is an interface to support dynamic dispatch.
type IChrfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsChrfuncContext differentiates from other interfaces.
	IsChrfuncContext()
}

type ChrfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChrfuncContext() *ChrfuncContext {
	var p = new(ChrfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_chrfunc
	return p
}

func InitEmptyChrfuncContext(p *ChrfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_chrfunc
}

func (*ChrfuncContext) IsChrfuncContext() {}

func NewChrfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChrfuncContext {
	var p = new(ChrfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_chrfunc

	return p
}

func (s *ChrfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *ChrfuncContext) CHR() antlr.TerminalNode {
	return s.GetToken(BasicParserCHR, 0)
}

func (s *ChrfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *ChrfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ChrfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *ChrfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChrfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChrfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitChrfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Chrfunc() (localctx IChrfuncContext) {
	localctx = NewChrfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, BasicParserRULE_chrfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(762)
		p.Match(BasicParserCHR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(763)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(764)
		p.Expression()
	}
	{
		p.SetState(765)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILenfuncContext is an interface to support dynamic dispatch.
type ILenfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsLenfuncContext differentiates from other interfaces.
	IsLenfuncContext()
}

type LenfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLenfuncContext() *LenfuncContext {
	var p = new(LenfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_lenfunc
	return p
}

func InitEmptyLenfuncContext(p *LenfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_lenfunc
}

func (*LenfuncContext) IsLenfuncContext() {}

func NewLenfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LenfuncContext {
	var p = new(LenfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_lenfunc

	return p
}

func (s *LenfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *LenfuncContext) LEN() antlr.TerminalNode {
	return s.GetToken(BasicParserLEN, 0)
}

func (s *LenfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *LenfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LenfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *LenfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LenfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LenfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitLenfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Lenfunc() (localctx ILenfuncContext) {
	localctx = NewLenfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, BasicParserRULE_lenfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(767)
		p.Match(BasicParserLEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(768)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(769)
		p.Expression()
	}
	{
		p.SetState(770)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAscfuncContext is an interface to support dynamic dispatch.
type IAscfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASC() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsAscfuncContext differentiates from other interfaces.
	IsAscfuncContext()
}

type AscfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAscfuncContext() *AscfuncContext {
	var p = new(AscfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_ascfunc
	return p
}

func InitEmptyAscfuncContext(p *AscfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_ascfunc
}

func (*AscfuncContext) IsAscfuncContext() {}

func NewAscfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AscfuncContext {
	var p = new(AscfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_ascfunc

	return p
}

func (s *AscfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *AscfuncContext) ASC() antlr.TerminalNode {
	return s.GetToken(BasicParserASC, 0)
}

func (s *AscfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *AscfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AscfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *AscfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AscfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AscfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitAscfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Ascfunc() (localctx IAscfuncContext) {
	localctx = NewAscfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, BasicParserRULE_ascfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(772)
		p.Match(BasicParserASC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(773)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(774)
		p.Expression()
	}
	{
		p.SetState(775)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMidfuncContext is an interface to support dynamic dispatch.
type IMidfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MID() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsMidfuncContext differentiates from other interfaces.
	IsMidfuncContext()
}

type MidfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMidfuncContext() *MidfuncContext {
	var p = new(MidfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_midfunc
	return p
}

func InitEmptyMidfuncContext(p *MidfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_midfunc
}

func (*MidfuncContext) IsMidfuncContext() {}

func NewMidfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MidfuncContext {
	var p = new(MidfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_midfunc

	return p
}

func (s *MidfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *MidfuncContext) MID() antlr.TerminalNode {
	return s.GetToken(BasicParserMID, 0)
}

func (s *MidfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *MidfuncContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MidfuncContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MidfuncContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BasicParserCOMMA)
}

func (s *MidfuncContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, i)
}

func (s *MidfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *MidfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MidfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MidfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitMidfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Midfunc() (localctx IMidfuncContext) {
	localctx = NewMidfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, BasicParserRULE_midfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(777)
		p.Match(BasicParserMID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(778)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(779)
		p.Expression()
	}
	{
		p.SetState(780)
		p.Match(BasicParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(781)
		p.Expression()
	}
	{
		p.SetState(782)
		p.Match(BasicParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(783)
		p.Expression()
	}
	{
		p.SetState(784)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPdlfuncContext is an interface to support dynamic dispatch.
type IPdlfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PDL() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsPdlfuncContext differentiates from other interfaces.
	IsPdlfuncContext()
}

type PdlfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPdlfuncContext() *PdlfuncContext {
	var p = new(PdlfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_pdlfunc
	return p
}

func InitEmptyPdlfuncContext(p *PdlfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_pdlfunc
}

func (*PdlfuncContext) IsPdlfuncContext() {}

func NewPdlfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PdlfuncContext {
	var p = new(PdlfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_pdlfunc

	return p
}

func (s *PdlfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *PdlfuncContext) PDL() antlr.TerminalNode {
	return s.GetToken(BasicParserPDL, 0)
}

func (s *PdlfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *PdlfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PdlfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *PdlfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PdlfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PdlfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitPdlfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Pdlfunc() (localctx IPdlfuncContext) {
	localctx = NewPdlfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, BasicParserRULE_pdlfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(786)
		p.Match(BasicParserPDL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(787)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(788)
		p.Expression()
	}
	{
		p.SetState(789)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPeekfuncContext is an interface to support dynamic dispatch.
type IPeekfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PEEK() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsPeekfuncContext differentiates from other interfaces.
	IsPeekfuncContext()
}

type PeekfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPeekfuncContext() *PeekfuncContext {
	var p = new(PeekfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_peekfunc
	return p
}

func InitEmptyPeekfuncContext(p *PeekfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_peekfunc
}

func (*PeekfuncContext) IsPeekfuncContext() {}

func NewPeekfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PeekfuncContext {
	var p = new(PeekfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_peekfunc

	return p
}

func (s *PeekfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *PeekfuncContext) PEEK() antlr.TerminalNode {
	return s.GetToken(BasicParserPEEK, 0)
}

func (s *PeekfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *PeekfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PeekfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *PeekfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PeekfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PeekfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitPeekfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Peekfunc() (localctx IPeekfuncContext) {
	localctx = NewPeekfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, BasicParserRULE_peekfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(791)
		p.Match(BasicParserPEEK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(792)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(793)
		p.Expression()
	}
	{
		p.SetState(794)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntfuncContext is an interface to support dynamic dispatch.
type IIntfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsIntfuncContext differentiates from other interfaces.
	IsIntfuncContext()
}

type IntfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntfuncContext() *IntfuncContext {
	var p = new(IntfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_intfunc
	return p
}

func InitEmptyIntfuncContext(p *IntfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_intfunc
}

func (*IntfuncContext) IsIntfuncContext() {}

func NewIntfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntfuncContext {
	var p = new(IntfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_intfunc

	return p
}

func (s *IntfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *IntfuncContext) INTF() antlr.TerminalNode {
	return s.GetToken(BasicParserINTF, 0)
}

func (s *IntfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *IntfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *IntfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitIntfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Intfunc() (localctx IIntfuncContext) {
	localctx = NewIntfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, BasicParserRULE_intfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(796)
		p.Match(BasicParserINTF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(797)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(798)
		p.Expression()
	}
	{
		p.SetState(799)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpcfuncContext is an interface to support dynamic dispatch.
type ISpcfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SPC() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsSpcfuncContext differentiates from other interfaces.
	IsSpcfuncContext()
}

type SpcfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpcfuncContext() *SpcfuncContext {
	var p = new(SpcfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_spcfunc
	return p
}

func InitEmptySpcfuncContext(p *SpcfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_spcfunc
}

func (*SpcfuncContext) IsSpcfuncContext() {}

func NewSpcfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpcfuncContext {
	var p = new(SpcfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_spcfunc

	return p
}

func (s *SpcfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *SpcfuncContext) SPC() antlr.TerminalNode {
	return s.GetToken(BasicParserSPC, 0)
}

func (s *SpcfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *SpcfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SpcfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *SpcfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpcfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpcfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitSpcfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Spcfunc() (localctx ISpcfuncContext) {
	localctx = NewSpcfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, BasicParserRULE_spcfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(801)
		p.Match(BasicParserSPC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(802)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(803)
		p.Expression()
	}
	{
		p.SetState(804)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrefuncContext is an interface to support dynamic dispatch.
type IFrefuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FRE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsFrefuncContext differentiates from other interfaces.
	IsFrefuncContext()
}

type FrefuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrefuncContext() *FrefuncContext {
	var p = new(FrefuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_frefunc
	return p
}

func InitEmptyFrefuncContext(p *FrefuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_frefunc
}

func (*FrefuncContext) IsFrefuncContext() {}

func NewFrefuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrefuncContext {
	var p = new(FrefuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_frefunc

	return p
}

func (s *FrefuncContext) GetParser() antlr.Parser { return s.parser }

func (s *FrefuncContext) FRE() antlr.TerminalNode {
	return s.GetToken(BasicParserFRE, 0)
}

func (s *FrefuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *FrefuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FrefuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *FrefuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrefuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrefuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitFrefunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Frefunc() (localctx IFrefuncContext) {
	localctx = NewFrefuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, BasicParserRULE_frefunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(806)
		p.Match(BasicParserFRE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(807)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(808)
		p.Expression()
	}
	{
		p.SetState(809)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPosfuncContext is an interface to support dynamic dispatch.
type IPosfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	POS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsPosfuncContext differentiates from other interfaces.
	IsPosfuncContext()
}

type PosfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPosfuncContext() *PosfuncContext {
	var p = new(PosfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_posfunc
	return p
}

func InitEmptyPosfuncContext(p *PosfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_posfunc
}

func (*PosfuncContext) IsPosfuncContext() {}

func NewPosfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PosfuncContext {
	var p = new(PosfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_posfunc

	return p
}

func (s *PosfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *PosfuncContext) POS() antlr.TerminalNode {
	return s.GetToken(BasicParserPOS, 0)
}

func (s *PosfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *PosfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PosfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *PosfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PosfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PosfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitPosfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Posfunc() (localctx IPosfuncContext) {
	localctx = NewPosfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, BasicParserRULE_posfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(811)
		p.Match(BasicParserPOS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(812)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(813)
		p.Expression()
	}
	{
		p.SetState(814)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsrfuncContext is an interface to support dynamic dispatch.
type IUsrfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsUsrfuncContext differentiates from other interfaces.
	IsUsrfuncContext()
}

type UsrfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsrfuncContext() *UsrfuncContext {
	var p = new(UsrfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_usrfunc
	return p
}

func InitEmptyUsrfuncContext(p *UsrfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_usrfunc
}

func (*UsrfuncContext) IsUsrfuncContext() {}

func NewUsrfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsrfuncContext {
	var p = new(UsrfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_usrfunc

	return p
}

func (s *UsrfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *UsrfuncContext) USR() antlr.TerminalNode {
	return s.GetToken(BasicParserUSR, 0)
}

func (s *UsrfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *UsrfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UsrfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *UsrfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsrfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsrfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitUsrfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Usrfunc() (localctx IUsrfuncContext) {
	localctx = NewUsrfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, BasicParserRULE_usrfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(816)
		p.Match(BasicParserUSR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(817)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(818)
		p.Expression()
	}
	{
		p.SetState(819)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILeftfuncContext is an interface to support dynamic dispatch.
type ILeftfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	COMMA() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsLeftfuncContext differentiates from other interfaces.
	IsLeftfuncContext()
}

type LeftfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeftfuncContext() *LeftfuncContext {
	var p = new(LeftfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_leftfunc
	return p
}

func InitEmptyLeftfuncContext(p *LeftfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_leftfunc
}

func (*LeftfuncContext) IsLeftfuncContext() {}

func NewLeftfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeftfuncContext {
	var p = new(LeftfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_leftfunc

	return p
}

func (s *LeftfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *LeftfuncContext) LEFT() antlr.TerminalNode {
	return s.GetToken(BasicParserLEFT, 0)
}

func (s *LeftfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *LeftfuncContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LeftfuncContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LeftfuncContext) COMMA() antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, 0)
}

func (s *LeftfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *LeftfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeftfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeftfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitLeftfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Leftfunc() (localctx ILeftfuncContext) {
	localctx = NewLeftfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, BasicParserRULE_leftfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(821)
		p.Match(BasicParserLEFT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(822)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(823)
		p.Expression()
	}
	{
		p.SetState(824)
		p.Match(BasicParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(825)
		p.Expression()
	}
	{
		p.SetState(826)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRightfuncContext is an interface to support dynamic dispatch.
type IRightfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RIGHT() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	COMMA() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsRightfuncContext differentiates from other interfaces.
	IsRightfuncContext()
}

type RightfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRightfuncContext() *RightfuncContext {
	var p = new(RightfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_rightfunc
	return p
}

func InitEmptyRightfuncContext(p *RightfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_rightfunc
}

func (*RightfuncContext) IsRightfuncContext() {}

func NewRightfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RightfuncContext {
	var p = new(RightfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_rightfunc

	return p
}

func (s *RightfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *RightfuncContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(BasicParserRIGHT, 0)
}

func (s *RightfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *RightfuncContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RightfuncContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RightfuncContext) COMMA() antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, 0)
}

func (s *RightfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *RightfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RightfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RightfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitRightfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Rightfunc() (localctx IRightfuncContext) {
	localctx = NewRightfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, BasicParserRULE_rightfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(828)
		p.Match(BasicParserRIGHT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(829)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(830)
		p.Expression()
	}
	{
		p.SetState(831)
		p.Match(BasicParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(832)
		p.Expression()
	}
	{
		p.SetState(833)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStrfuncContext is an interface to support dynamic dispatch.
type IStrfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsStrfuncContext differentiates from other interfaces.
	IsStrfuncContext()
}

type StrfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrfuncContext() *StrfuncContext {
	var p = new(StrfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_strfunc
	return p
}

func InitEmptyStrfuncContext(p *StrfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_strfunc
}

func (*StrfuncContext) IsStrfuncContext() {}

func NewStrfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrfuncContext {
	var p = new(StrfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_strfunc

	return p
}

func (s *StrfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *StrfuncContext) STR() antlr.TerminalNode {
	return s.GetToken(BasicParserSTR, 0)
}

func (s *StrfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *StrfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StrfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *StrfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StrfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitStrfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Strfunc() (localctx IStrfuncContext) {
	localctx = NewStrfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, BasicParserRULE_strfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(835)
		p.Match(BasicParserSTR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(836)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(837)
		p.Expression()
	}
	{
		p.SetState(838)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnfuncContext is an interface to support dynamic dispatch.
type IFnfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FN() antlr.TerminalNode
	Var_() IVar_Context
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsFnfuncContext differentiates from other interfaces.
	IsFnfuncContext()
}

type FnfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnfuncContext() *FnfuncContext {
	var p = new(FnfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_fnfunc
	return p
}

func InitEmptyFnfuncContext(p *FnfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_fnfunc
}

func (*FnfuncContext) IsFnfuncContext() {}

func NewFnfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnfuncContext {
	var p = new(FnfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_fnfunc

	return p
}

func (s *FnfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *FnfuncContext) FN() antlr.TerminalNode {
	return s.GetToken(BasicParserFN, 0)
}

func (s *FnfuncContext) Var_() IVar_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVar_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVar_Context)
}

func (s *FnfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *FnfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FnfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *FnfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitFnfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Fnfunc() (localctx IFnfuncContext) {
	localctx = NewFnfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, BasicParserRULE_fnfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(840)
		p.Match(BasicParserFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(841)
		p.Var_()
	}
	{
		p.SetState(842)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(843)
		p.Expression()
	}
	{
		p.SetState(844)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValfuncContext is an interface to support dynamic dispatch.
type IValfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VAL() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsValfuncContext differentiates from other interfaces.
	IsValfuncContext()
}

type ValfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValfuncContext() *ValfuncContext {
	var p = new(ValfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_valfunc
	return p
}

func InitEmptyValfuncContext(p *ValfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_valfunc
}

func (*ValfuncContext) IsValfuncContext() {}

func NewValfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValfuncContext {
	var p = new(ValfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_valfunc

	return p
}

func (s *ValfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *ValfuncContext) VAL() antlr.TerminalNode {
	return s.GetToken(BasicParserVAL, 0)
}

func (s *ValfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *ValfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ValfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *ValfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitValfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Valfunc() (localctx IValfuncContext) {
	localctx = NewValfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, BasicParserRULE_valfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(846)
		p.Match(BasicParserVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(847)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(848)
		p.Expression()
	}
	{
		p.SetState(849)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScrnfuncContext is an interface to support dynamic dispatch.
type IScrnfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SCRN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	COMMA() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsScrnfuncContext differentiates from other interfaces.
	IsScrnfuncContext()
}

type ScrnfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScrnfuncContext() *ScrnfuncContext {
	var p = new(ScrnfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_scrnfunc
	return p
}

func InitEmptyScrnfuncContext(p *ScrnfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_scrnfunc
}

func (*ScrnfuncContext) IsScrnfuncContext() {}

func NewScrnfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScrnfuncContext {
	var p = new(ScrnfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_scrnfunc

	return p
}

func (s *ScrnfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *ScrnfuncContext) SCRN() antlr.TerminalNode {
	return s.GetToken(BasicParserSCRN, 0)
}

func (s *ScrnfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *ScrnfuncContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ScrnfuncContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ScrnfuncContext) COMMA() antlr.TerminalNode {
	return s.GetToken(BasicParserCOMMA, 0)
}

func (s *ScrnfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *ScrnfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScrnfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScrnfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitScrnfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Scrnfunc() (localctx IScrnfuncContext) {
	localctx = NewScrnfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, BasicParserRULE_scrnfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(851)
		p.Match(BasicParserSCRN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(852)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(853)
		p.Expression()
	}
	{
		p.SetState(854)
		p.Match(BasicParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(855)
		p.Expression()
	}
	{
		p.SetState(856)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISinfuncContext is an interface to support dynamic dispatch.
type ISinfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SIN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsSinfuncContext differentiates from other interfaces.
	IsSinfuncContext()
}

type SinfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySinfuncContext() *SinfuncContext {
	var p = new(SinfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_sinfunc
	return p
}

func InitEmptySinfuncContext(p *SinfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_sinfunc
}

func (*SinfuncContext) IsSinfuncContext() {}

func NewSinfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SinfuncContext {
	var p = new(SinfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_sinfunc

	return p
}

func (s *SinfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *SinfuncContext) SIN() antlr.TerminalNode {
	return s.GetToken(BasicParserSIN, 0)
}

func (s *SinfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *SinfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SinfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *SinfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SinfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SinfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitSinfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Sinfunc() (localctx ISinfuncContext) {
	localctx = NewSinfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, BasicParserRULE_sinfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(858)
		p.Match(BasicParserSIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(859)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(860)
		p.Expression()
	}
	{
		p.SetState(861)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICosfuncContext is an interface to support dynamic dispatch.
type ICosfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsCosfuncContext differentiates from other interfaces.
	IsCosfuncContext()
}

type CosfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCosfuncContext() *CosfuncContext {
	var p = new(CosfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_cosfunc
	return p
}

func InitEmptyCosfuncContext(p *CosfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_cosfunc
}

func (*CosfuncContext) IsCosfuncContext() {}

func NewCosfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CosfuncContext {
	var p = new(CosfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_cosfunc

	return p
}

func (s *CosfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *CosfuncContext) COS() antlr.TerminalNode {
	return s.GetToken(BasicParserCOS, 0)
}

func (s *CosfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *CosfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CosfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *CosfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CosfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CosfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitCosfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Cosfunc() (localctx ICosfuncContext) {
	localctx = NewCosfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, BasicParserRULE_cosfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(863)
		p.Match(BasicParserCOS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(864)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(865)
		p.Expression()
	}
	{
		p.SetState(866)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITanfuncContext is an interface to support dynamic dispatch.
type ITanfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TAN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsTanfuncContext differentiates from other interfaces.
	IsTanfuncContext()
}

type TanfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTanfuncContext() *TanfuncContext {
	var p = new(TanfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_tanfunc
	return p
}

func InitEmptyTanfuncContext(p *TanfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_tanfunc
}

func (*TanfuncContext) IsTanfuncContext() {}

func NewTanfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TanfuncContext {
	var p = new(TanfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_tanfunc

	return p
}

func (s *TanfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *TanfuncContext) TAN() antlr.TerminalNode {
	return s.GetToken(BasicParserTAN, 0)
}

func (s *TanfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *TanfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TanfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *TanfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TanfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TanfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitTanfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Tanfunc() (localctx ITanfuncContext) {
	localctx = NewTanfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, BasicParserRULE_tanfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(868)
		p.Match(BasicParserTAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(869)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(870)
		p.Expression()
	}
	{
		p.SetState(871)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAtnfuncContext is an interface to support dynamic dispatch.
type IAtnfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ATN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsAtnfuncContext differentiates from other interfaces.
	IsAtnfuncContext()
}

type AtnfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtnfuncContext() *AtnfuncContext {
	var p = new(AtnfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_atnfunc
	return p
}

func InitEmptyAtnfuncContext(p *AtnfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_atnfunc
}

func (*AtnfuncContext) IsAtnfuncContext() {}

func NewAtnfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtnfuncContext {
	var p = new(AtnfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_atnfunc

	return p
}

func (s *AtnfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *AtnfuncContext) ATN() antlr.TerminalNode {
	return s.GetToken(BasicParserATN, 0)
}

func (s *AtnfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *AtnfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AtnfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *AtnfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtnfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtnfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitAtnfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Atnfunc() (localctx IAtnfuncContext) {
	localctx = NewAtnfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, BasicParserRULE_atnfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(873)
		p.Match(BasicParserATN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(874)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(875)
		p.Expression()
	}
	{
		p.SetState(876)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRndfuncContext is an interface to support dynamic dispatch.
type IRndfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RND() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsRndfuncContext differentiates from other interfaces.
	IsRndfuncContext()
}

type RndfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRndfuncContext() *RndfuncContext {
	var p = new(RndfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_rndfunc
	return p
}

func InitEmptyRndfuncContext(p *RndfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_rndfunc
}

func (*RndfuncContext) IsRndfuncContext() {}

func NewRndfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RndfuncContext {
	var p = new(RndfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_rndfunc

	return p
}

func (s *RndfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *RndfuncContext) RND() antlr.TerminalNode {
	return s.GetToken(BasicParserRND, 0)
}

func (s *RndfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *RndfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RndfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *RndfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RndfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RndfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitRndfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Rndfunc() (localctx IRndfuncContext) {
	localctx = NewRndfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, BasicParserRULE_rndfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(878)
		p.Match(BasicParserRND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(879)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(880)
		p.Expression()
	}
	{
		p.SetState(881)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISgnfuncContext is an interface to support dynamic dispatch.
type ISgnfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SGN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsSgnfuncContext differentiates from other interfaces.
	IsSgnfuncContext()
}

type SgnfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySgnfuncContext() *SgnfuncContext {
	var p = new(SgnfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_sgnfunc
	return p
}

func InitEmptySgnfuncContext(p *SgnfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_sgnfunc
}

func (*SgnfuncContext) IsSgnfuncContext() {}

func NewSgnfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SgnfuncContext {
	var p = new(SgnfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_sgnfunc

	return p
}

func (s *SgnfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *SgnfuncContext) SGN() antlr.TerminalNode {
	return s.GetToken(BasicParserSGN, 0)
}

func (s *SgnfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *SgnfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SgnfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *SgnfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SgnfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SgnfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitSgnfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Sgnfunc() (localctx ISgnfuncContext) {
	localctx = NewSgnfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, BasicParserRULE_sgnfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(883)
		p.Match(BasicParserSGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(884)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(885)
		p.Expression()
	}
	{
		p.SetState(886)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpfuncContext is an interface to support dynamic dispatch.
type IExpfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXP() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsExpfuncContext differentiates from other interfaces.
	IsExpfuncContext()
}

type ExpfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpfuncContext() *ExpfuncContext {
	var p = new(ExpfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_expfunc
	return p
}

func InitEmptyExpfuncContext(p *ExpfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_expfunc
}

func (*ExpfuncContext) IsExpfuncContext() {}

func NewExpfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpfuncContext {
	var p = new(ExpfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_expfunc

	return p
}

func (s *ExpfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpfuncContext) EXP() antlr.TerminalNode {
	return s.GetToken(BasicParserEXP, 0)
}

func (s *ExpfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *ExpfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *ExpfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitExpfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Expfunc() (localctx IExpfuncContext) {
	localctx = NewExpfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, BasicParserRULE_expfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(888)
		p.Match(BasicParserEXP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(889)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(890)
		p.Expression()
	}
	{
		p.SetState(891)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogfuncContext is an interface to support dynamic dispatch.
type ILogfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOG() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsLogfuncContext differentiates from other interfaces.
	IsLogfuncContext()
}

type LogfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogfuncContext() *LogfuncContext {
	var p = new(LogfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_logfunc
	return p
}

func InitEmptyLogfuncContext(p *LogfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_logfunc
}

func (*LogfuncContext) IsLogfuncContext() {}

func NewLogfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogfuncContext {
	var p = new(LogfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_logfunc

	return p
}

func (s *LogfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *LogfuncContext) LOG() antlr.TerminalNode {
	return s.GetToken(BasicParserLOG, 0)
}

func (s *LogfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *LogfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *LogfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitLogfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Logfunc() (localctx ILogfuncContext) {
	localctx = NewLogfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, BasicParserRULE_logfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(893)
		p.Match(BasicParserLOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(894)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(895)
		p.Expression()
	}
	{
		p.SetState(896)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbsfuncContext is an interface to support dynamic dispatch.
type IAbsfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsAbsfuncContext differentiates from other interfaces.
	IsAbsfuncContext()
}

type AbsfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbsfuncContext() *AbsfuncContext {
	var p = new(AbsfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_absfunc
	return p
}

func InitEmptyAbsfuncContext(p *AbsfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_absfunc
}

func (*AbsfuncContext) IsAbsfuncContext() {}

func NewAbsfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbsfuncContext {
	var p = new(AbsfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_absfunc

	return p
}

func (s *AbsfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *AbsfuncContext) ABS() antlr.TerminalNode {
	return s.GetToken(BasicParserABS, 0)
}

func (s *AbsfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *AbsfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AbsfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *AbsfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbsfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbsfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitAbsfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Absfunc() (localctx IAbsfuncContext) {
	localctx = NewAbsfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, BasicParserRULE_absfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(898)
		p.Match(BasicParserABS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(899)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(900)
		p.Expression()
	}
	{
		p.SetState(901)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITabfuncContext is an interface to support dynamic dispatch.
type ITabfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TAB() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsTabfuncContext differentiates from other interfaces.
	IsTabfuncContext()
}

type TabfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTabfuncContext() *TabfuncContext {
	var p = new(TabfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_tabfunc
	return p
}

func InitEmptyTabfuncContext(p *TabfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BasicParserRULE_tabfunc
}

func (*TabfuncContext) IsTabfuncContext() {}

func NewTabfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabfuncContext {
	var p = new(TabfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BasicParserRULE_tabfunc

	return p
}

func (s *TabfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *TabfuncContext) TAB() antlr.TerminalNode {
	return s.GetToken(BasicParserTAB, 0)
}

func (s *TabfuncContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserLPAREN, 0)
}

func (s *TabfuncContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TabfuncContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BasicParserRPAREN, 0)
}

func (s *TabfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabfuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BasicVisitor:
		return t.VisitTabfunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BasicParser) Tabfunc() (localctx ITabfuncContext) {
	localctx = NewTabfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, BasicParserRULE_tabfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(903)
		p.Match(BasicParserTAB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(904)
		p.Match(BasicParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(905)
		p.Expression()
	}
	{
		p.SetState(906)
		p.Match(BasicParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
